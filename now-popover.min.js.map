{"version":3,"sources":["webpack://__TECTONIC__$servicenow_now_popover/webpack/bootstrap","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__$servicenow_ui_renderer_snabbdom\"","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/get-axis-info.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__$servicenow_library_enhanced_element_19_8_3\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__$servicenow_library_enhanced_utils_19_8_3\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__$servicenow_ui_core\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/dom.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"isEmpty\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/index.js","webpack://__TECTONIC__$servicenow_now_popover/./src/now-popover.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/index.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/fit-info.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/dimensions.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/calculate-fit.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/content-area.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/content-area-styles.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/content.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/content-styles.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/overlap.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/constrain.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/to-size-value.js","webpack://__TECTONIC__$servicenow_now_popover/./src/fit/is-target-visible.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"isEqual\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"once\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"noop\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/tail.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"find\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/focus.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"inRange\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/global-event-listener.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"forEachRight\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"debounce\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/observer.js","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/scroll-listener.js","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/resolve-fit-properties.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"isString\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"isNumber\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"isArray\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__lodash_4_17_4[\\\"mapValues\\\"]\"","webpack://__TECTONIC__$servicenow_now_popover/./src/utils/normalize-position.js","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__resize_observer_polyfill_1_5_1\"","webpack://__TECTONIC__$servicenow_now_popover/external \"__TECTONIC__$servicenow_behavior_focus_19_8_3\"","webpack://__TECTONIC__$servicenow_now_popover/./src/now-popover-panel.js","webpack://__TECTONIC__$servicenow_now_popover/./src/_now-popover-panel.scss?3577","webpack://__TECTONIC__$servicenow_now_popover/./src/_now-popover-panel.scss","webpack://__TECTONIC__$servicenow_now_popover//mnt/jenkins/workspace/motive_design-system_quebec-LAU4EC4LTND4QOM764JRONU2HSYHYZ6QDWUSLZIXTBP7KKZ7BWQQ/target/checkout/node_modules/css-loader/lib/css-base.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","__TECTONIC__$servicenow_ui_renderer_snabbdom","axis","topOrLeft","bottomOrRight","widthOrHeight","__TECTONIC__$servicenow_library_enhanced_element_19_8_3","__TECTONIC__$servicenow_library_enhanced_utils_19_8_3","__TECTONIC__$servicenow_ui_core","getContent","host","querySelectorAll","getFirstTrigger","querySelector","isNestedPanel","element","parentPanel","tagName","root","nowPopover","getRootNode","contains","findTriggerFromEvent","event","slot","assignedNodes","flatten","length","composedPath","node","index","path","hoist","async","container","nodes","panel","document","createElement","Promise","resolve","onReady","append","nowHoistAppendTo","nowHoist","unhoist","content","remove","findAncestors","id","eventName","findListener","removeEventListener","e","ancestors","Set","idx","nodeType","Node","ELEMENT_NODE","nowId","forEach","ancestor","add","addEventListener","CustomEvent","bubbles","composed","cancelable","dispatchEvent","__TECTONIC__lodash_4_17_4","createNowPopoverDriver","createNowPopoverPanelDriver","version","require","registry","window","___NOW_DESIGN_SYSTEM_PACKAGES___","COMPONENT_CONNECTED","COMPONENT_DISCONNECTED","COMPONENT_PROPERTY_CHANGED","actionTypes","onWindowResize","batch","clickListener","scrollListener","intersectionObserver","IntersectionObserver","resizeObserver","ResizeObserver","closePopover","dispatch","layerEvents","openPopover","disableScroll","updateState","shouldRender","operation","finishedOpening","type","payload","handlePopoverOpened","updateFit","target","trigger","fitContent","fitContentArea","targetPosition","contentPosition","interactionType","some","handleClick","events","callback","preventDefault","stopPropagation","handleTabPress","handleKeyDown","moveFocusIfNeeded","focusFirstItemInPanel","noop","targetVisible","style","display","visibility","entries","isTargetVisible","threshold","includes","isTabInPanel","shiftKey","focusTarget","findNextFocusTarget","within","focus","createEnhancedElement","properties","default","schema","enum","hideTail","positionTarget","opened","manageable","positions","items","oneOf","required","constrain","width","const","minWidth","maxWidth","height","minHeight","maxHeight","offset","body","initialState","restoreFocus","undefined","clickedTrigger","actionHandlers","updateProperties","refit","action","state","meta","previousValue","modifier","limit","effect","dir","shadowRoot","removeAttribute","fitProps","contentArea","fitInfo","getBestFitInfo","assign","dimensions","targetDimensions","contentAreaDimensions","dispatches","slots","behaviors","behavior","focusBehavior","view","ref","createRef","on-slotchange","on-click","handleSlotClick","current","getFitInfo","sortCandidates","viewport","cacheDimensions","getDimensions","contentDimensions","containerDimensions","viewportDimensions","candidates","pos","info","position","overlapRatios","push","sort","a","b","viewportOverlapDifference","canScroll","overflow","dim","HTMLElement","documentElement","top","right","clientWidth","bottom","clientHeight","left","existing","scroll","block","scrollY","inline","scrollX","scrollHeight","scrollWidth","box","getBoundingClientRect","Math","round","scrollTop","scrollLeft","getComputedStyle","parseInt","overflowX","max","overflowY","normOffset","Array","isArray","backwardCompatibleOffset","slice","find","makeOffsetBackwardsCompatible","calcOffset","normalizeOffset","normConstrain","normalizeConstrain","constrainedContentDimensions","applyConstrain","paddedTargetDimensions","addOffsetPaddingToDimensions","nextContentAreaDimensions","nextContentDimensions","visibleContentDimensions","contentAreaStyles","contentStyles","calculateContentAreaLength","calculateContentAreaOffset","targetPositionBlock","targetPositionInline","contentPositionBlock","contentPositionInline","floor","min","pointerEvents","calculateContentOffset","getConstrainStyles","reduce","result","addCSSProperties","isBottomAligned","isEndAligned","restrictToBoundingBox","boundingDimensions","ratio","visibleDimensions","contentInContainer","contentInViewport","getDimensionForConstrainKey","constraint","normalizedConstrain","newDimensions","startsWith","contentValue","targetValue","constrainValue","Error","entry","intersectionRatio","boundingClientRect","targetRect","intersectionRect","blockPosition","inlinePosition","replace","isVisible","direction","getTailPosition","setProperty","tailDirection","middleOfTarget","deltaX","TAIL_LENGTH","deltaY","firstFocusableElement","getActiveElement","wrap","delta","tabbableNodes","findTabbableNodes","currentIndex","indexOf","eventType","callbacks","runCallbacks","needsToAttach","Observer","observed","Map","observerArgs","observer","observe","set","unobserve","delete","attached","targets","el","listener","source","has","resolvePosition","resolveOffset","resolveConstrain","positionToFitShorthand","map","RE_POSITION_LONG","test","targetOrigin","contentOrigin","split","normalizeOrigin","RE_POSITION_SHORT","vertical","horizontal","toMatchingOrigin","origin","match","group","isStart","__TECTONIC__resize_observer_polyfill_1_5_1","__TECTONIC__$servicenow_behavior_focus_19_8_3","COMPONENT_DOM_READY","styles","class","className","toString","useSourceMap","list","this","item","cssMapping","btoa","sourceMapping","sourceMap","unescape","encodeURIComponent","JSON","stringify","sourceURLs","sources","sourceRoot","concat","join","cssWithMappingToString","mediaQuery","alreadyImportedModules"],"mappings":"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","file":"now-popover.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","module.exports = __TECTONIC__$servicenow_ui_renderer_snabbdom;","/**\n * Returns directional information for the given axis.\n * @param {(\"block\"|\"inline\")} axis - Axis that is being calculated (block for top/bottom, inline for left/right)\n * @return {{topOrLeft: string, bottomOrRight: string, widthOrHeight: string}}\n */\nexport default function getAxisInfo(axis) {\n\treturn {\n\t\ttopOrLeft: axis === 'block' ? 'top' : 'left',\n\t\tbottomOrRight: axis === 'block' ? 'bottom' : 'right',\n\t\twidthOrHeight: axis === 'block' ? 'height' : 'width'\n\t};\n}\n","module.exports = __TECTONIC__$servicenow_library_enhanced_element_19_8_3;","module.exports = __TECTONIC__$servicenow_library_enhanced_utils_19_8_3;","module.exports = __TECTONIC__$servicenow_ui_core;","import find from 'lodash/find';\n\nconst POPOVER_PANEL_TAG = 'NOW-POPOVER-PANEL';\n\nexport function getContent(host) {\n\treturn host.querySelectorAll('[slot=content]');\n}\n\nexport function getFirstTrigger(host) {\n\treturn host.querySelector('[slot=trigger]');\n}\n\n/**\n * Checks if the given element is a popover panel that is nested within a\n * another panel.\n *\n * @param element - The element to check\n * @param parentPanel - The panel that may contain the element\n *\n * @returns {boolean} `true` if the element is itself a panel that is\n * originally contained within the `parentPanel`. Otherwise, returns `false`.\n */\nexport function isNestedPanel(element, parentPanel) {\n\tif (!element || !parentPanel || element.tagName !== POPOVER_PANEL_TAG) {\n\t\treturn false;\n\t}\n\n\tlet root = element.nowPopover;\n\twhile ((root = root.getRootNode()) !== null) {\n\t\tif (!root.host) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (parentPanel.contains(root.host)) {\n\t\t\treturn true;\n\t\t}\n\n\t\troot = root.host;\n\t}\n}\n\n/**\n * Determine which slotted trigger was interacted with.\n */\nexport function findTriggerFromEvent(event, slot) {\n\tconst assignedNodes = slot.assignedNodes({flatten: true});\n\n\tif (assignedNodes.length === 0) {\n\t\treturn null;\n\t}\n\n\tif (assignedNodes.length === 1) {\n\t\treturn assignedNodes[0];\n\t}\n\n\t// if there are multiple slotted triggers, the one that we want will be right\n\t// before the <slot> node in the composed path\n\treturn find(event.composedPath(), (node, index, path) => {\n\t\tconst nextNode = path[index + 1];\n\t\treturn nextNode === slot;\n\t});\n}\n\n/**\n * Dynamically create a `<now-popover-panel />` element in the correct location\n * in the DOM and hoist slotted content to that element. We want Seismic to\n * control hoisting the content so that actions and events can be re-routed\n * correctly, but we still need want to include the now-popover-panel as a\n * parent to ensure we have the correct markup and styles required to use\n * getBestFitInfo.\n *\n * We also can't hoist the now-popover-panel directly, because it wouldn't be\n * able to take the content (slotted into the parent now-popover) along with\n * it.\n */\nexport async function hoist(host, container, nodes) {\n\tconst panel = document.createElement(POPOVER_PANEL_TAG);\n\n\t// provide a reference back to the original <now-popover> from the panel\n\t// element. This is used so that we can figure out the original DOM order of\n\t// elements when we receive an event from the hoisted panel.\n\tpanel.nowPopover = host;\n\n\t// Seismic will render the panel asynchronously, so we need to wait for that\n\t// to happen. Since we're creating the panel outside of a normal view\n\t// function/render hierarchy, we can't really listen for an action to be\n\t// dispatched from the panel. Instead, we have a custom callback function\n\t// that panel calls once it has been rendered :(\n\treturn await new Promise((resolve) => {\n\t\tpanel.onReady = resolve;\n\n\t\tcontainer.append(panel);\n\n\t\tfor (const node of nodes) {\n\t\t\tnode.nowHoistAppendTo = panel;\n\t\t\tnode.nowHoist = true;\n\t\t}\n\t});\n}\n\nexport function unhoist(panel, content) {\n\tfor (const node of content) {\n\t\tnode.nowHoist = false;\n\t}\n\n\tif (panel) {\n\t\tpanel.remove();\n\t}\n}\n\n/**\n * Attaches a listener to the container, then fires a fake event from the given element\n * to identify all ancestor elements in the element's DOM tree. More efficient than\n * climbing the tree recursively.\n * @param {string} id - unique ID\n * @param {HTMLElement} element - the element to find ancestors of\n * @param {HTMLElement} container - the topmost element to resolve to\n */\nexport const findAncestors = (id, element, container) =>\n\tnew Promise((resolve) => {\n\t\tconst eventName = `findAncestors-${id}`;\n\t\tconst findListener = async (e) => {\n\t\t\tcontainer.removeEventListener(eventName, findListener);\n\t\t\tconst path = e.composedPath();\n\t\t\tconst length = path.length;\n\t\t\tconst ancestors = new Set(path);\n\n\t\t\t// This is gross but since popovers are hoisted,\n\t\t\t// any child popovers will lose context of their parent's\n\t\t\t// scroll containers. To fix this, we can lookup the parent\n\t\t\t// popover and recurse for its ancestors, then merge\n\t\t\t// the hoisted and non-hoisted ancestor lists. Ideally we\n\t\t\t// could memoize these but since we don't control data on\n\t\t\t// the host, it's risky to store the memoized nodes\n\t\t\t// in a public property.\n\t\t\tfor (let idx = 0; idx < length; idx++) {\n\t\t\t\tconst node = path[idx];\n\t\t\t\tif (\n\t\t\t\t\tnode !== element &&\n\t\t\t\t\tnode.nodeType === Node.ELEMENT_NODE &&\n\t\t\t\t\tnode.tagName === POPOVER_PANEL_TAG\n\t\t\t\t) {\n\t\t\t\t\tconst parentAncestors = await findAncestors(\n\t\t\t\t\t\tnode.nowId,\n\t\t\t\t\t\tnode.nowPopover,\n\t\t\t\t\t\tcontainer\n\t\t\t\t\t);\n\n\t\t\t\t\tparentAncestors.forEach((ancestor) => ancestors.add(ancestor));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tresolve(ancestors);\n\t\t};\n\n\t\tcontainer.addEventListener(eventName, findListener);\n\t\tconst event = new CustomEvent(eventName, {\n\t\t\tbubbles: true,\n\t\t\tcomposed: true,\n\t\t\tcancelable: false\n\t\t});\n\t\telement.dispatchEvent(event);\n\t});\n","module.exports = __TECTONIC__lodash_4_17_4[\"isEmpty\"];","import './now-popover';\nimport './now-popover-panel';\nexport {createNowPopoverDriver, createNowPopoverPanelDriver} from '../drivers';\n\n/*\n * TODO: This is a temporary way of debugging customer problems during the\n * Seismic 18 upgrade process, because tectonic resolution makes it hard to\n * know what version of a component is running. Remove when not needed.\n * Intentionally runs in dev + production environments so we can debug all builds.\n */\nconst {name, version} = require('../package.json');\nconst registry = (window.___NOW_DESIGN_SYSTEM_PACKAGES___ =\n\twindow.___NOW_DESIGN_SYSTEM_PACKAGES___ || {});\nif (!registry[name]) {\n\tregistry[name] = version;\n}\n","import {createEnhancedElement} from '@servicenow/library-enhanced-element';\nimport {layerEvents} from '@servicenow/library-enhanced-utils';\nimport {actionTypes} from '@servicenow/ui-core';\nimport {createRef} from '@servicenow/ui-renderer-snabbdom';\nimport {getBestFitInfo, isTargetVisible} from './fit';\nimport isEqual from 'lodash/isEqual';\nimport once from 'lodash/once';\nimport noop from 'lodash/noop';\nimport setTailPosition from './utils/tail';\nimport {\n\tgetContent,\n\tgetFirstTrigger,\n\tisNestedPanel,\n\tfindTriggerFromEvent,\n\thoist,\n\tunhoist\n} from './utils/dom';\nimport {findNextFocusTarget, focusFirstItemInPanel} from './utils/focus';\nimport createGlobalListener from './utils/global-event-listener';\nimport createObserver from './utils/observer';\nimport createScrollListener from './utils/scroll-listener';\nimport resolveFitProperties from './utils/resolve-fit-properties';\nimport ResizeObserver from 'resize-observer-polyfill';\nimport focusBehavior from '@servicenow/behavior-focus';\n\nconst {\n\tCOMPONENT_CONNECTED,\n\tCOMPONENT_DISCONNECTED,\n\tCOMPONENT_PROPERTY_CHANGED\n} = actionTypes;\n\nconst onWindowResize = createGlobalListener('resize', {batch: true});\nconst clickListener = createGlobalListener('click');\nconst scrollListener = createScrollListener();\nconst intersectionObserver = createObserver(IntersectionObserver);\nconst resizeObserver = createObserver(ResizeObserver);\n\n/**\n * Closes the popover. Removes any listeners that we've added and moves the\n * content back into the normal, non-hoisted location\n */\nfunction closePopover({id, panel, host, dispatch}) {\n\tlayerEvents.remove(id);\n\tclickListener.remove(id);\n\tonWindowResize.remove(id);\n\tscrollListener.remove(id);\n\tintersectionObserver.remove(id);\n\n\tconst content = getContent(host);\n\tunhoist(panel, content);\n\n\tdispatch('NOW_POPOVER#CONTENT_HIDDEN', {});\n}\n\n/**\n * Opens the popover. Hoists the content nodes to the proper location and then\n * calls fit.\n */\nasync function openPopover({\n\thost,\n\tcontainer,\n\tdisableScroll,\n\tdispatch,\n\tupdateState\n}) {\n\tconst content = getContent(host);\n\n\t// invalid markup. No content has been slotted\n\tif (content.length === 0) {\n\t\treturn;\n\t}\n\n\tconst panel = await hoist(host, container, content);\n\tpanel.disableScroll = disableScroll;\n\n\tupdateState({\n\t\tshouldRender: false,\n\t\toperation: 'assign',\n\t\tvalue: {\n\t\t\tpanel,\n\t\t\tfinishedOpening: false\n\t\t}\n\t});\n\n\tdispatch(() => ({type: 'PRIVATE#CHECK_FIT', payload: {}}));\n}\n\nfunction handleKeyDown(\n\tevent,\n\tpanel,\n\ttrigger,\n\tinteractionType,\n\tdispatch,\n\tupdateState\n) {\n\t// escape closes the popover and refocuses the trigger\n\tif (event.key === 'Escape') {\n\t\tevent.preventDefault();\n\t\tevent.stopPropagation();\n\n\t\tdispatch(() => ({\n\t\t\ttype: 'NOW_POPOVER#OPENED_SET',\n\t\t\tpayload: {value: false}\n\t\t}));\n\n\t\t// return false to ensure parent popovers don't also respond to Escape\n\t\treturn false;\n\t}\n\n\t// tab moves focus, but the exact behavior depends on the interactionType\n\tif (event.key === 'Tab') {\n\t\thandleTabPress({\n\t\t\tevent,\n\t\t\tpanel,\n\t\t\tdispatch,\n\t\t\ttrigger,\n\t\t\tinteractionType,\n\t\t\tupdateState\n\t\t});\n\t}\n}\n\nfunction handleClick(event, host, panel, dispatch, updateState) {\n\tconst path = event.composedPath();\n\n\t// DEF0088795: The click event originates from the hoisted element in the\n\t// DOM. But if that hoisted component defines a Seismic eventHandler,\n\t// Seismic will re-emit that event from the original (unhoisted) content\n\t// host.\n\t//\n\t// So even though it feels like a single click event, there are actually 2\n\t// events being propagated, each with a different path. We need to know if\n\t// both of these events originate from the panel in order to correctly\n\t// _not_ dispatch OPENED_SET.\n\t//\n\t// `path` will include `panel` on the first click event, since the panel is\n\t// dynamically created and holds the hoisted element.\n\t//\n\t// `path` will include `host` on the 2nd click event, since the host is a\n\t// parent of the original (unhoisted) content node.\n\t//\n\t// We also need to guard against events coming from a nested popover panel\n\t// (e.g.: when we have a <now-select> in the content of a bigger\n\t// <now-popover>). These panels are hoisted independently, so the outer\n\t// panel is not in the composedPath of the inner panel.\n\tconst hostInPath = path.some((element) => {\n\t\treturn (\n\t\t\telement === host || element === panel || isNestedPanel(element, panel)\n\t\t);\n\t});\n\n\tif (!hostInPath) {\n\t\tupdateState({\n\t\t\tshouldRender: false,\n\t\t\toperation: 'set',\n\t\t\tpath: 'restoreFocus',\n\t\t\tvalue: false\n\t\t});\n\t\tdispatch(() => ({\n\t\t\ttype: 'NOW_POPOVER#OPENED_SET',\n\t\t\tpayload: {value: false}\n\t\t}));\n\t}\n}\n\n/**\n * Once the popover is opened and we've fit the panel, we want to set up a\n * bunch of listeners to track things like: outside clicks, tab navigation,\n * scrolling, and focus management.\n */\nfunction handlePopoverOpened({\n\tid,\n\thost,\n\tpanel,\n\tupdateFit,\n\ttarget,\n\tcontent,\n\ttrigger,\n\tcontainer,\n\tdispatch,\n\tupdateState,\n\tfitContent,\n\tfitContentArea,\n\ttargetPosition,\n\tcontentPosition,\n\tinteractionType\n}) {\n\t// refit any time the window is resized. This is not using `updateFit`\n\t// because we do want to allow the fit position to change (otherwise a resize\n\t// might make panel content inaccessible).\n\tonWindowResize.add(id, () => dispatch(() => ({type: 'PRIVATE#CHECK_FIT'})));\n\n\tclickListener.add(id, (event) => {\n\t\thandleClick(event, host, panel, dispatch, updateState);\n\t});\n\tlayerEvents.add({\n\t\tid,\n\t\tevents: ['keydown'],\n\t\tcallback: (event) => {\n\t\t\thandleKeyDown(\n\t\t\t\tevent,\n\t\t\t\tpanel,\n\t\t\t\ttrigger,\n\t\t\t\tinteractionType,\n\t\t\t\tdispatch,\n\t\t\t\tupdateState\n\t\t\t);\n\t\t}\n\t});\n\n\t// for dialog type popovers: we want to move focus to the first item in the\n\t// panel once the panel has been opened. However, we need to delay this until\n\t// the IntersectionObserver has fired and sets the visibility of contentArea\n\t// to visible.\n\tconst moveFocusIfNeeded =\n\t\tinteractionType === 'dialog' ? once(focusFirstItemInPanel) : noop;\n\n\t// When the target element is scrolled out-of-view, we want to stop showing\n\t// the panel. Similarly, when the target is scrolled back into view, we want\n\t// to show the panel again.\n\t//\n\t// Unlike Chrome/Firefox, Safari may not immediately trigger the callback\n\t// when the IntersectionObserver is first connected, so we can't rely on that\n\t// callback to initialize `targetVisible` or the correct styles. Since we\n\t// just called fit, assume that we're all good to display this until we get\n\t// an IntersectionObserver event that says we can't.\n\tlet targetVisible = true;\n\tfitContentArea.style.display = 'block';\n\tfitContentArea.style.visibility = 'visible';\n\n\tintersectionObserver.add(\n\t\tid,\n\t\ttarget,\n\t\t(entries) => {\n\t\t\ttargetVisible = isTargetVisible(targetPosition, entries[0]);\n\t\t\tfitContentArea.style.display = targetVisible ? 'block' : 'none';\n\t\t\tfitContentArea.style.visibility = targetVisible ? 'visible' : 'hidden';\n\n\t\t\tif (targetVisible) {\n\t\t\t\tmoveFocusIfNeeded(panel);\n\t\t\t}\n\t\t},\n\n\t\t// these thresholds allow the intersection observer to fire on the\n\t\t// beginning, middle, and end of the target crossing the viewport. We want\n\t\t// these because depending on the target fit position, we need to check the\n\t\t// visibility of different points on the target.\n\t\t//\n\t\t// e.g.: if the target position is \"top-center\" and we are scrolling down,\n\t\t// we want to be able to check the visibility as soon as any part of the\n\t\t// target is falling off vertically (threshold = 0). When scrolling\n\t\t// horizontally, we can continue to show panel up until the middle point of\n\t\t// the target crosses the viewport (thresold = 0.5)\n\t\t{threshold: [0, 0.5, 1]}\n\t);\n\n\t// refit when scrolling, but force the position to remain the same\n\tscrollListener.add(id, host, container, () => {\n\t\tif (targetVisible) {\n\t\t\tupdateFit();\n\t\t}\n\t});\n\n\tif (contentPosition.includes('center')) {\n\t\tresizeObserver.add(id, fitContent, () => {\n\t\t\tif (targetVisible) {\n\t\t\t\tupdateFit();\n\t\t\t}\n\t\t});\n\t}\n\n\t// tell the world that we're all good to go :+1:\n\tdispatch(() => ({\n\t\ttype: 'NOW_POPOVER#CONTENT_VISIBLE',\n\t\tpayload: {\n\t\t\tcontent\n\t\t}\n\t}));\n}\n\n/**\n * Event handler for when the `Tab` key is pressed while the popover is opened.\n * Depending on the interactionType property we will focus different elements.\n */\nconst handleTabPress = ({\n\tevent,\n\ttrigger,\n\tpanel,\n\tdispatch,\n\tinteractionType,\n\tupdateState\n}) => {\n\t// when the popover does not contain interactive content, we can just let the\n\t// browser natively handle the Tab.\n\tif (interactionType === 'none') {\n\t\tupdateState({\n\t\t\tshouldRender: false,\n\t\t\toperation: 'set',\n\t\t\tpath: 'restoreFocus',\n\t\t\tvalue: false\n\t\t});\n\t\tdispatch(() => ({\n\t\t\ttype: 'NOW_POPOVER#OPENED_SET',\n\t\t\tpayload: {value: false}\n\t\t}));\n\t\treturn;\n\t}\n\n\t// listbox interactions do not have a focus trap. shift-tab returns focus\n\t// back to the trigger element. Regular tab moves focus to the item after the\n\t// trigger, which can be handled natively. Regardless, the popover is closed\n\tif (interactionType === 'listbox') {\n\t\tconst isTabInPanel = event.composedPath().includes(panel);\n\t\tif (event.shiftKey && trigger) {\n\t\t\tevent.preventDefault();\n\t\t} else if (isTabInPanel) {\n\t\t\tevent.preventDefault();\n\t\t\tupdateState({\n\t\t\t\tshouldRender: false,\n\t\t\t\toperation: 'set',\n\t\t\t\tpath: 'restoreFocus',\n\t\t\t\tvalue: true\n\t\t\t});\n\t\t} else {\n\t\t\tupdateState({\n\t\t\t\tshouldRender: false,\n\t\t\t\toperation: 'set',\n\t\t\t\tpath: 'restoreFocus',\n\t\t\t\tvalue: false\n\t\t\t});\n\t\t}\n\t\tdispatch('NOW_POPOVER#OPENED_SET', {value: false});\n\t\treturn;\n\t}\n\n\t// dialog types trap focus within the content and keep the popover open\n\tif (interactionType === 'dialog') {\n\t\tevent.preventDefault();\n\t\tconst focusTarget = findNextFocusTarget({\n\t\t\twithin: panel,\n\t\t\tshiftKey: event.shiftKey\n\t\t});\n\n\t\tif (focusTarget) {\n\t\t\tfocusTarget.focus();\n\t\t}\n\t}\n};\n\n/**\n * Callback when the something in the `trigger` slot has been clicked. Need to\n * keep track of which trigger was clicked (in case multiple triggers are slotted\n * in), and then toggle the open state of the panel.\n */\nconst handleSlotClick = ({event, dispatch, updateState, slot}) => {\n\tconst clickedTrigger = findTriggerFromEvent(event, slot);\n\n\t// this can happen if you click, drag, and release off one trigger and on to\n\t// another. In that case the composedPath no longer includes the original\n\t// trigger.\n\tif (!clickedTrigger) {\n\t\treturn;\n\t}\n\n\tevent.stopPropagation();\n\n\t// keep track of which trigger was clicked. This is needed to know where to\n\t// position the panel (when there is no explicit `position-target`) and to\n\t// track which element to restore focus to once the panel is closed.\n\tupdateState({\n\t\toperation: 'set',\n\t\tpath: 'clickedTrigger',\n\t\tvalue: clickedTrigger,\n\t\tshouldRender: false\n\t});\n\n\tdispatch(({properties}) => {\n\t\treturn {\n\t\t\ttype: 'NOW_POPOVER#OPENED_SET',\n\t\t\tpayload: {\n\t\t\t\tvalue: !properties.opened\n\t\t\t}\n\t\t};\n\t});\n};\n\nconst view = (state, {dispatch, updateState}) => {\n\tconst {opened} = state.properties;\n\n\tconst ref = createRef();\n\n\treturn (\n\t\t<slot\n\t\t\tname=\"trigger\"\n\t\t\tref={ref}\n\t\t\ton-slotchange={\n\t\t\t\topened ? () => dispatch(() => ({type: 'PRIVATE#CHECK_FIT'})) : undefined\n\t\t\t}\n\t\t\ton-click={(event) =>\n\t\t\t\thandleSlotClick({\n\t\t\t\t\tevent,\n\t\t\t\t\tdispatch,\n\t\t\t\t\tupdateState,\n\t\t\t\t\tslot: ref.current\n\t\t\t\t})\n\t\t\t}\n\t\t/>\n\t);\n};\n\n/**\n * A popover lets you float temporary contextual content over other content,\n * relative to a triggering element.\n *\n * Popover content is placed in a panel element, which optionally provides\n * a visual tail that points the content back to its triggering element.\n * Both the content and triggering elements are customizable.\n *\n * In order to correctly position the content, the popover will hoist the\n * content out of the normal DOM flow and append it to the body. Therefore, the\n * content element that is used must be a Now® Experience UI Component in order\n * to correctly encapsulate styles and propagate actions.\n *\n * ```jsx\n * <now-popover>\n *\t <now-button slot=\"trigger\" label=\"Check out my popover\" />\n *\t <now-my-dialog slot=\"content\" />\n * </now-popover>\n * ```\n *\n * `now-popover` elements define a `refit()` method that can be used to force\n * the popover to recalculate the position of the panel. This is useful when\n * something changes the layout or causes elements to move when the popover is\n * already open.\n *\n * @seismicElement now-popover\n * @summary Temporary contextual content that displays over other content when a user selects the triggering element.\n */\ncreateEnhancedElement('now-popover', {\n\tproperties: {\n\t\t/**\n\t\t * Type of content displayed in the popover. These types are similar to\n\t\t * ARIA roles and control how the popover manages focus.\n\t\t *\n\t\t * Valid values are:\n\t\t * - \"dialog\": Content contains interactive content. Focus\n\t\t *   stays within the content while the popover is opened.\n\t\t *   An example of this is a calendar picker.\n\t\t * - \"listbox\": Content contains a list of items that a user\n\t\t *   can select from (typically using the arrow keys). Focus does not stay\n\t\t *   within the content when the popover is opened. An example of this is\n\t\t *   a dropdown.\n\t\t * - \"none\": Content contains no interactive content.\n\t\t *   An example of this is a tooltip.\n\t\t *\n\t\t * @type {(\"dialog\"|\"none\"|\"listbox\")}\n\t\t * @private\n\t\t */\n\t\tinteractionType: {\n\t\t\tdefault: 'dialog',\n\t\t\tschema: {type: 'string', enum: ['dialog', 'none', 'listbox']}\n\t\t},\n\t\t/**\n\t\t * If true, the popover does not include a visual tail that points\n\t\t * the content back to the trigger. Setting this property to true\n\t\t * changes the default value of the `positions` property.\n\t\t *\n\t\t * See the `positions` property for more details.\n\t\t * @type {boolean}\n\t\t */\n\t\thideTail: {default: false, schema: {type: 'boolean'}},\n\t\t/**\n\t\t * The element that triggers the content. If not specified,\n\t\t * the trigger slot triggers the content.\n\t\t *\n\t\t * @type {HTMLElement}\n\t\t **/\n\t\tpositionTarget: {},\n\t\t/**\n\t\t * When true, the popover opens. The value of this property automatically updates\n\t\t * when the user opens or closes the popover unless the `manage-opened` property is set.\n\t\t * You can use the `manage-opened` property to override the default behavior and handle the\n\t\t * `NOW_POPOVER#OPENED_SET` action manually.\n\t\t *\n\t\t * Note: Popover content may not be\n\t\t * positioned and visible when `NOW_POPOVER#OPENED_SET`\n\t\t * dispatches. See `NOW_POPOVER#CONTENT_VISIBLE` for\n\t\t * an action that dispatches only when content is correctly\n\t\t * positioned.\n\t\t * @type {{value: boolean}}\n\t\t */\n\t\topened: {default: false, manageable: true, schema: {type: 'boolean'}},\n\t\t/**\n\t\t * A list of possible positions to place the content relative to its\n\t\t * target, in order of preference. The content is placed in the\n\t\t * position that fits best.\n\t\t *\n\t\t * Each object in `positions` specifies which points on the target and\n\t\t * content elements align. The value of a point describes the\n\t\t * block then inline location on the edge of the element:\n\t\t *\n\t\t *  - top-start\n\t\t *  - top-center\n\t\t *  - top-end\n\t\t *  - center-end\n\t\t *  - bottom-end\n\t\t *  - bottom-center\n\t\t *  - bottom-start\n\t\t *  - center-start\n\t\t *\n\t\t * In a left-to-right language, `top-start` would be at the topmost and\n\t\t * leftmost point of the element, with each successive value moving\n\t\t * clockwise around the element.\n\t\t *\n\t\t * For example:\n\t\t *\n\t\t * The following aligns the bottom center of the content to the top center\n\t\t * of the target, which is commonly used for tooltip-like content:\n\t\t *\n\t\t *   { target: 'top-center', content: 'bottom-center' }\n\t\t *\n\t\t * To have the content positioned to the right of the target (in a\n\t\t * left-to-right language):\n\t\t *\n\t\t *   { target: 'center-end', content: 'center-start' }\n\t\t *\n\t\t * A common dropdown position, where content is aligned to the start of the\n\t\t * target and opens below the target:\n\t\t *\n\t\t *   { target: 'bottom-start', content: 'top-start' }\n\t\t *\n\t\t *\n\t\t * The default value depends on whether or not the popover includes a tail.\n\t\t * With a tail, the default positions center the content and the trigger:\n\t\t *\n\t\t *  [\n\t\t *    { target: 'top-center', content: 'bottom-center' },\n\t\t *    { target: 'bottom-center', content: 'top-center' },\n\t\t *    { target: 'center-end', content: 'center-start' },\n\t\t *    { target: 'center-start', content: 'center-end' }\n\t\t *  ]\n\t\t *\n\t\t * Without a tail, the default positions align the content and target\n\t\t * along an axis:\n\t\t *\n\t\t * \t[\n\t\t * \t\t{ target: 'bottom-start', content: 'top-start' },\n\t\t * \t\t{ target: 'bottom-end', content: 'top-end' },\n\t\t * \t\t{ target: 'top-start', content: 'bottom-start' },\n\t\t * \t\t{ target: 'top-end', content: 'bottom-end' },\n\t\t * \t\t{ target: 'top-end', content: 'top-start' },\n\t\t * \t\t{ target: 'bottom-end', content: 'bottom-start' },\n\t\t * \t\t{ target: 'top-start', content: 'top-end' },\n\t\t * \t\t{ target: 'bottom-start', content: 'bottom-end' }\n\t\t * \t];\n\t\t *\n\t\t * When overriding the default value, provide\n\t\t * multiple position objects to this property. This practice allows for\n\t\t * alternative placements in the case where the content does not\n\t\t * completely fit in the preferred position.\n\t\t *\n\t\t * @type {Array<{target: string, content: string}>}\n\t\t */\n\t\tpositions: {\n\t\t\tschema: {\n\t\t\t\ttype: 'array',\n\t\t\t\titems: {\n\t\t\t\t\toneOf: [\n\t\t\t\t\t\t{type: 'string'},\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttype: 'object',\n\t\t\t\t\t\t\tproperties: {\n\t\t\t\t\t\t\t\ttarget: {\n\t\t\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\t\t\tenum: [\n\t\t\t\t\t\t\t\t\t\t'top-start',\n\t\t\t\t\t\t\t\t\t\t'top-center',\n\t\t\t\t\t\t\t\t\t\t'top-end',\n\t\t\t\t\t\t\t\t\t\t'center-start',\n\t\t\t\t\t\t\t\t\t\t'center-end',\n\t\t\t\t\t\t\t\t\t\t'bottom-start',\n\t\t\t\t\t\t\t\t\t\t'bottom-center',\n\t\t\t\t\t\t\t\t\t\t'bottom-end'\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tcontent: {\n\t\t\t\t\t\t\t\t\ttype: 'string',\n\t\t\t\t\t\t\t\t\tenum: [\n\t\t\t\t\t\t\t\t\t\t'top-start',\n\t\t\t\t\t\t\t\t\t\t'top-center',\n\t\t\t\t\t\t\t\t\t\t'top-end',\n\t\t\t\t\t\t\t\t\t\t'center-start',\n\t\t\t\t\t\t\t\t\t\t'center-end',\n\t\t\t\t\t\t\t\t\t\t'bottom-start',\n\t\t\t\t\t\t\t\t\t\t'bottom-center',\n\t\t\t\t\t\t\t\t\t\t'bottom-end'\n\t\t\t\t\t\t\t\t\t]\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\trequired: ['target']\n\t\t\t\t\t\t}\n\t\t\t\t\t]\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Optional sizing constraints to enforce on the popover content. Valid keys are:\n\t\t *\n\t\t *  - width\n\t\t *  - minWidth\n\t\t *  - maxWidth\n\t\t *  - height\n\t\t *  - minHeight\n\t\t *  - maxHeight\n\t\t *\n\t\t * The value for each key must be a positive integer representing a\n\t\t * pixel value to apply to the corresponding content style.\n\t\t * Alternatively, you can specify the string `\"target\"` to have the content\n\t\t * match the value of the target element.\n\t\t *\n\t\t * For example, to ensure the content is at least 400x200 pixels:\n\t\t *\n\t\t *  {\n\t\t *\t\t\"minWidth\": 400,\n\t\t *\t\t\"minHeight\": 200\n\t\t *  }\n\t\t *\n\t\t * To ensure that the content is always as wide as its target:\n\t\t *\n\t\t *\t{\n\t\t *\t\t\"width\": \"target\"\n\t\t *\t}\n\t\t *\n\t\t * @private\n\t\t * @type {PopoverConstrain}\n\t\t */\n\t\tconstrain: {\n\t\t\tschema: {\n\t\t\t\ttype: 'object',\n\t\t\t\tproperties: {\n\t\t\t\t\twidth: {oneOf: [{const: 'target'}, {type: 'number'}]},\n\t\t\t\t\tminWidth: {oneOf: [{const: 'target'}, {type: 'number'}]},\n\t\t\t\t\tmaxWidth: {oneOf: [{const: 'target'}, {type: 'number'}]},\n\t\t\t\t\theight: {oneOf: [{const: 'target'}, {type: 'number'}]},\n\t\t\t\t\tminHeight: {oneOf: [{const: 'target'}, {type: 'number'}]},\n\t\t\t\t\tmaxHeight: {oneOf: [{const: 'target'}, {type: 'number'}]}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Number of pixels to shift the popover content away from the trigger.\n\t\t * @type {number}\n\t\t * @private\n\t\t */\n\t\toffset: {schema: {type: ['array', 'number']}},\n\t\t/**\n\t\t * Which element to hoist the popover panel to.\n\t\t * @type {HTMLElement}\n\t\t * @private\n\t\t */\n\t\tcontainer: {\n\t\t\tget default() {\n\t\t\t\treturn document.body;\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * If true, content in the popover panel will not overflow with a scrollbar.\n\t\t * Use this flag if your popover content already contains a custom\n\t\t * scroll container for handling overflowed content.\n\t\t * @type {boolean}\n\t\t */\n\t\tdisableScroll: {schema: {type: 'boolean'}}\n\t},\n\tinitialState: {\n\t\t/**\n\t\t * Whether or not the popover should restore\n\t\t * focus to the trigger element when the popover\n\t\t * is closed\n\t\t */\n\t\trestoreFocus: true,\n\t\t/**\n\t\t * A reference to the `now-popover-panel` element that is dynamically\n\t\t * created when the popover is opened.\n\t\t */\n\t\tpanel: undefined,\n\t\t/**\n\t\t * Because Seismic dispatches and renders are asynchronous, the panel and\n\t\t * its contents are not rendered and hoisted immediately when the `opened`\n\t\t * prop is set. This state value tracks when we know that the DOM is in a\n\t\t * good spot and we can add event listeners and fire\n\t\t * `NOW_POPOVER#CONTENT_VISIBLE`\n\t\t */\n\t\tfinishedOpening: false,\n\t\t/**\n\t\t * When multiple triggers are slotted in, this value tracks which one of those\n\t\t * triggers is responsible for causing the popover to be opened.\n\t\t */\n\t\tclickedTrigger: undefined\n\t},\n\tactionHandlers: {\n\t\t[COMPONENT_CONNECTED]: function handleConnected({\n\t\t\tupdateState,\n\t\t\tdispatch,\n\t\t\tproperties,\n\t\t\thost,\n\t\t\tupdateProperties\n\t\t}) {\n\t\t\t// In standalone HTML apps, the Seismic default value for `container`\n\t\t\t// is evaluated before `document.body` exists\n\t\t\tif (!properties.container) {\n\t\t\t\tupdateProperties({container: document.body});\n\t\t\t}\n\n\t\t\t// Adds a public `refit()` method on the host of the popover, which will\n\t\t\t// force the popover to re-run fit. This works kind of like the focus\n\t\t\t// behavior, where we're adding public methods to give the consumer control\n\t\t\t// over when to do something that doesn't really fit in the props-down\n\t\t\t// actions-up model.\n\t\t\thost.refit = () => dispatch('PRIVATE#CHECK_FIT');\n\n\t\t\tif (properties.opened) {\n\t\t\t\topenPopover({\n\t\t\t\t\thost,\n\t\t\t\t\tcontainer: properties.container,\n\t\t\t\t\tdisableScroll: properties.disableScroll,\n\t\t\t\t\tdispatch,\n\t\t\t\t\tupdateState\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[COMPONENT_DISCONNECTED]: function handleDisconnected({\n\t\t\taction,\n\t\t\tdispatch,\n\t\t\tstate,\n\t\t\tproperties\n\t\t}) {\n\t\t\tif (properties.opened) {\n\t\t\t\tclosePopover({\n\t\t\t\t\tpanel: state.panel,\n\t\t\t\t\tid: action.meta.id,\n\t\t\t\t\thost: action.payload.host,\n\t\t\t\t\tdispatch\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t\t[COMPONENT_PROPERTY_CHANGED]: function handlePropertyChanged({\n\t\t\taction,\n\t\t\tdispatch,\n\t\t\tproperties,\n\t\t\tstate,\n\t\t\tupdateState\n\t\t}) {\n\t\t\tconst {host, name, value, previousValue} = action.payload;\n\n\t\t\t// If a property related to fit changes we need to re-run fit\n\t\t\tif (\n\t\t\t\tname === 'positions' ||\n\t\t\t\tname === 'offset' ||\n\t\t\t\tname === 'constrain' ||\n\t\t\t\t(name === 'positionTarget' && previousValue)\n\t\t\t) {\n\t\t\t\t// Deep equality check because non-scalar props (offset, position,\n\t\t\t\t// etc) might change all the time and this is cheaper than recalcing\n\t\t\t\t// all of fit.\n\t\t\t\tif (!isEqual(value, previousValue)) {\n\t\t\t\t\tdispatch(() => ({type: 'PRIVATE#CHECK_FIT'}));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (name === 'opened') {\n\t\t\t\tconst {id} = action.meta;\n\t\t\t\tconst {restoreFocus} = state;\n\n\t\t\t\tif (value) {\n\t\t\t\t\topenPopover({\n\t\t\t\t\t\thost,\n\t\t\t\t\t\tcontainer: properties.container,\n\t\t\t\t\t\tdisableScroll: properties.disableScroll,\n\t\t\t\t\t\tdispatch,\n\t\t\t\t\t\tupdateState\n\t\t\t\t\t});\n\t\t\t\t\tupdateState({\n\t\t\t\t\t\tshouldRender: false,\n\t\t\t\t\t\toperation: 'set',\n\t\t\t\t\t\tpath: 'restoreFocus',\n\t\t\t\t\t\tvalue: true\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\tclosePopover({\n\t\t\t\t\t\tid,\n\t\t\t\t\t\thost,\n\t\t\t\t\t\tpanel: state.panel,\n\t\t\t\t\t\tdispatch\n\t\t\t\t\t});\n\t\t\t\t\tconst trigger = state.clickedTrigger || getFirstTrigger(host);\n\t\t\t\t\tif (restoreFocus && trigger) {\n\t\t\t\t\t\ttrigger.focus();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t/**\n\t\t * Checks to see if we have everything we need to run fit. If so,\n\t\t * do it and apply the styles to the panel.\n\t\t */\n\t\t'PRIVATE#CHECK_FIT': {\n\t\t\tstopPropagation: true,\n\t\t\tmodifier: {\n\t\t\t\ttype: 'throttle',\n\t\t\t\tlimit: 10\n\t\t\t},\n\t\t\teffect: ({host, state, action, dispatch, properties, updateState}) => {\n\t\t\t\tconst {panel, clickedTrigger} = state;\n\t\t\t\tconst {\n\t\t\t\t\tdir,\n\t\t\t\t\topened,\n\t\t\t\t\tcontainer,\n\t\t\t\t\tpositionTarget,\n\t\t\t\t\tinteractionType\n\t\t\t\t} = properties;\n\t\t\t\tconst content = getContent(host);\n\t\t\t\tconst trigger = clickedTrigger || getFirstTrigger(host);\n\t\t\t\tconst target = positionTarget || trigger;\n\t\t\t\tconst fitContentArea =\n\t\t\t\t\tpanel && panel.shadowRoot.querySelector('#fit-content-area');\n\t\t\t\tconst fitContent =\n\t\t\t\t\tpanel && panel.shadowRoot.querySelector('#fit-content');\n\n\t\t\t\tif (!opened || !target || !content || !fitContentArea || !fitContent) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Switching from content center position to non center position while\n\t\t\t\t// open can cause incorrect calculations.\n\t\t\t\tfitContent.removeAttribute('style');\n\n\t\t\t\t// set up a smaller, more focused fit function that we can call on\n\t\t\t\t// scroll or content resize. We don't want to go through the entire\n\t\t\t\t// PRIVATE#CHECK_FIT action for a couple reasons:\n\t\t\t\t//\n\t\t\t\t// - dispatched actions are scheduled, causing a somewhat noticeable\n\t\t\t\t// delay between the target moving and the panel refitting to catch up.\n\t\t\t\t//\n\t\t\t\t// - when scrolling: we don't want to let the fit position of the panel\n\t\t\t\t// change, because it's a poor user experience when the panel moves\n\t\t\t\t// around a lot after opening.\n\n\t\t\t\tlet fitProps = {\n\t\t\t\t\t...resolveFitProperties({\n\t\t\t\t\t\tdir,\n\t\t\t\t\t\tpositions: properties.positions,\n\t\t\t\t\t\tconstrain: properties.constrain,\n\t\t\t\t\t\thideTail: properties.hideTail,\n\t\t\t\t\t\toffset: properties.offset\n\t\t\t\t\t}),\n\t\t\t\t\ttarget,\n\t\t\t\t\tcontainer,\n\t\t\t\t\tcontent: fitContent,\n\t\t\t\t\tcontentArea: fitContentArea\n\t\t\t\t};\n\n\t\t\t\tconst updateFit = () => {\n\t\t\t\t\t// run fit calc\n\t\t\t\t\tconst fitInfo = getBestFitInfo({...fitProps});\n\n\t\t\t\t\t// apply styles from fitInfo\n\t\t\t\t\tObject.assign(fitContentArea.style, fitInfo.style.contentArea);\n\t\t\t\t\tObject.assign(fitContent.style, fitInfo.style.content);\n\n\t\t\t\t\t// position tail\n\t\t\t\t\tif (!properties.hideTail) {\n\t\t\t\t\t\tconst {dimensions, targetPosition, contentPosition} = fitInfo;\n\t\t\t\t\t\tsetTailPosition({\n\t\t\t\t\t\t\tcontentArea: fitContentArea,\n\t\t\t\t\t\t\ttargetPosition,\n\t\t\t\t\t\t\tcontentPosition,\n\t\t\t\t\t\t\ttargetDimensions: dimensions.target,\n\t\t\t\t\t\t\tpanel: state.panel,\n\t\t\t\t\t\t\tcontentAreaDimensions: dimensions.contentArea\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn fitInfo;\n\t\t\t\t};\n\n\t\t\t\tconst fitInfo = updateFit();\n\n\t\t\t\t// Let the first call to fit calculate the position and size of the\n\t\t\t\t// content. When we call updateFit again on scroll, we want to force\n\t\t\t\t// the same position and minimum content size\n\t\t\t\tfitProps.positions = [\n\t\t\t\t\t[fitInfo.targetPosition, fitInfo.contentPosition]\n\t\t\t\t];\n\n\t\t\t\t// set up listeners and handle focus, but only when we first open.\n\t\t\t\t// don't want to redo this stuff if PRIVATE#CHECK_FIT is called again\n\t\t\t\t// while the panel is already open.\n\t\t\t\tif (!state.finishedOpening) {\n\t\t\t\t\thandlePopoverOpened({\n\t\t\t\t\t\tid: action.meta.id,\n\t\t\t\t\t\thost,\n\t\t\t\t\t\tpanel,\n\t\t\t\t\t\ttarget,\n\t\t\t\t\t\tupdateFit,\n\t\t\t\t\t\tcontent,\n\t\t\t\t\t\ttrigger,\n\t\t\t\t\t\tcontainer,\n\t\t\t\t\t\tdispatch,\n\t\t\t\t\t\tupdateState,\n\t\t\t\t\t\tfitContent,\n\t\t\t\t\t\tfitContentArea,\n\t\t\t\t\t\ttargetPosition: fitInfo.targetPosition,\n\t\t\t\t\t\tcontentPosition: fitInfo.contentPosition,\n\t\t\t\t\t\tinteractionType\n\t\t\t\t\t});\n\n\t\t\t\t\tupdateState({\n\t\t\t\t\t\tshouldRender: false,\n\t\t\t\t\t\toperation: 'set',\n\t\t\t\t\t\tpath: 'finishedOpening',\n\t\t\t\t\t\tvalue: true\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\n\tdispatches: {\n\t\t/**\n\t\t * Dispatched when a user opens or closes the popover. Payload contains a\n\t\t * `value` property, which is `true` when the popover opens and\n\t\t * `false` when the popover closes.\n\t\t *\n\t\t * Note: Because rendering is asynchronous, the popover content DOM may not be in\n\t\t * the correct state when this action is dispatched.\n\t\t *\n\t\t * Use `NOW_POPOVER#CONTENT_VISIBLE` and `NOW_POPOVER#CONTENT_HIDDEN` actions\n\t\t * to run additional logic once the popover content is rendered in or\n\t\t * removed from the DOM respectively. Set the `manage-opened` property to override the default\n\t\t * behavior and handle this action manually.\n\t\t * @type {{value: boolean}}\n\t\t */\n\t\t'NOW_POPOVER#OPENED_SET': {},\n\n\t\t/**\n\t\t * Dispatched when the popover opens and renders the content. Unlike\n\t\t * `NOW_POPOVER#OPENED_SET`, this action only fires after the popover\n\t\t * content is rendered in the DOM. The `content` property contains the\n\t\t * slotted popover content.\n\t\t * @type {{content: Array<HTMLElement>}}\n\t\t * @private\n\t\t */\n\t\t'NOW_POPOVER#CONTENT_VISIBLE': {},\n\n\t\t/**\n\t\t * Dispatched when the popover content has been closed and removed. Unlike\n\t\t * `NOW_POPOVER#OPENED_SET`, this action only fires after the popover\n\t\t * content is fully removed from the DOM.\n\t\t * @type {{}}\n\t\t * @private\n\t\t */\n\t\t'NOW_POPOVER#CONTENT_HIDDEN': {}\n\t},\n\tslots: {\n\t\t/**\n\t\t * The trigger element that the popover content is positioned in relation to.\n\t\t * If the `manage-opened` property is not set, then clicking on this slot will\n\t\t * toggle the opened state of the popover.\n\t\t */\n\t\ttrigger: {},\n\n\t\t/**\n\t\t * The popover content that is visible when the `opened` property\n\t\t * is true. This *must* be a component and cannot inherit\n\t\t * styles from a parent element. If the content is not interactive,\n\t\t * you should wrap it in an `aria-live` region so that a\n\t\t * screenreader announces it when the popover opens.\n\t\t */\n\t\tcontent: {}\n\t},\n\tbehaviors: [{behavior: focusBehavior}],\n\tview\n});\n","export {default as getBestFitInfo, getFitInfo} from './fit-info';\nexport {default as isTargetVisible} from './is-target-visible';\n","import {getDimensions, cacheDimensions} from './dimensions';\nimport calculateFit from './calculate-fit';\n\nexport function sortCandidates(a, b) {\n\tconst viewportOverlapDifference =\n\t\tb.overlapRatios.viewport - a.overlapRatios.viewport;\n\n\t// first priority is to pick the position that fits the most content within\n\t// the viewport: we want the content to be immediately visible. If multiple\n\t// positions can fit the same amount of content in the viewport, then as a\n\t// tie-breaker we'll use the position that fits more within the container (to\n\t// minimize how much scrolling of the content is necessary).\n\tif (viewportOverlapDifference === 0) {\n\t\tconst containerOverlapDifference =\n\t\t\tb.overlapRatios.container - a.overlapRatios.container;\n\n\t\treturn containerOverlapDifference;\n\t}\n\n\treturn viewportOverlapDifference;\n}\n\n/**\n * Calculates the fit styles for the content with only one possible position.\n * @param {HTMLElement} target - Reference to element the content is positioned beside\n * @param {HTMLElement} content - Reference to positioned element\n * @param {HTMLElement} [container=window] - Reference to element content should fit within\n * @param {string[][]} - Desired position of content relative to target, e.g. [[\"top\", \"start\"], [\"bottom\", \"end\"]]\n * @param {number} [offset=0] - Amount to offset content from the target\n * @param {{height: number, width: number, minHeight: number, maxHeight: number, minWidth: number, maxWidth: number}} constrain - Constrains or sets the size of the content\n * @return {FitInfo}\n */\nexport function getFitInfo({\n\ttarget,\n\tcontent,\n\tcontentArea,\n\tcontainer = window,\n\tviewport = window,\n\tposition,\n\toffset = 0,\n\tconstrain = {}\n}) {\n\tconst targetDimensions = getDimensions(target);\n\tconst contentDimensions = getDimensions(content);\n\tconst containerDimensions = getDimensions(container);\n\tconst contentAreaDimensions = getDimensions(contentArea);\n\tconst viewportDimensions = getDimensions(viewport);\n\tconst [targetPosition, contentPosition] = position;\n\treturn calculateFit(\n\t\ttargetDimensions,\n\t\tcontentDimensions,\n\t\tcontentAreaDimensions,\n\t\tcontainerDimensions,\n\t\tviewportDimensions,\n\t\ttargetPosition,\n\t\tcontentPosition,\n\t\toffset,\n\t\tconstrain\n\t);\n}\n\n/**\n * Calculates the best fit styles for the content based on multiple possible\n * positions. Returns the fit info for the first position that completely fits.\n * If no position completely fits, returns the position that fits the most.\n * @param {HTMLElement} target - Reference to element the content is positioned beside\n * @param {HTMLElement} content - Reference to positioned element\n * @param {HTMLElement} [container=window] - Reference to element content should fit within\n * @param {string[][][]}- Desired positions of content relative to target in order of preferences, e.g. [[[\"bottom\", \"start\"],[\"top\", \"start\"]], [[\"top\", \"start\"], [\"bottom\", \"start\"]]]\n * @param {number} [offset=0] - Amount to offset content from the target\n * @param {{height: number, width: number, minHeight: number, maxHeight: number, minWidth: number, maxWidth: number}} constrain - Constrains or sets the size of the content\n * @return {FitInfo}\n */\nexport default function getBestFitInfo({\n\ttarget,\n\tcontent,\n\tcontentArea,\n\tcontainer = window,\n\tviewport = window,\n\tpositions,\n\toffset = 0,\n\tconstrain = {}\n}) {\n\tconst targetDimensions = cacheDimensions(getDimensions(target));\n\tconst contentDimensions = cacheDimensions(getDimensions(content));\n\tconst contentAreaDimensions = cacheDimensions(getDimensions(contentArea));\n\tconst containerDimensions = cacheDimensions(getDimensions(container));\n\tconst viewportDimensions = cacheDimensions(getDimensions(viewport));\n\tconst candidates = [];\n\tfor (const pos of positions) {\n\t\tconst info = getFitInfo({\n\t\t\ttarget: targetDimensions,\n\t\t\tcontent: contentDimensions,\n\t\t\tcontainer: containerDimensions,\n\t\t\tcontentArea: contentAreaDimensions,\n\t\t\tviewport: viewportDimensions,\n\t\t\tposition: pos,\n\t\t\toffset,\n\t\t\tconstrain\n\t\t});\n\n\t\t// Entire content fits in this position, no need to try other options\n\t\tif (\n\t\t\tinfo.overlapRatios.container === 1 &&\n\t\t\tinfo.overlapRatios.viewport === 1\n\t\t) {\n\t\t\treturn info;\n\t\t}\n\n\t\tcandidates.push(info);\n\t}\n\n\t/* Sort to find highest visible ratio, aka the one that fits the most content */\n\tcandidates.sort(sortCandidates);\n\n\treturn candidates[0];\n}\n","function canScroll(overflow) {\n\treturn overflow === 'auto' || overflow === 'hidden';\n}\n\n/**\n * Caches the result of a `getDimensions()` call so that it won't be\n * recalculated again later. Useful to ensure that getBoundingClientRect is\n * not called multiple times in a row when multiple fit positions are\n * evaluated in a row.\n * @param {Dimensions} dim\n * @return {{getDimensions: Function}}\n */\nexport function cacheDimensions(dim) {\n\treturn {\n\t\tgetDimensions: () => dim\n\t};\n}\n\n/**\n * Gets the dimensions of a HTMLElement or gets the manually specified and/or\n * cached dimensions of a DimensionsReference.\n * @param {(HTMLElement|DimensionsReference)} node\n * @return {Dimensions}\n */\nexport function getDimensions(node) {\n\tif (\n\t\t!(node instanceof HTMLElement) &&\n\t\ttypeof node.getDimensions === 'function'\n\t) {\n\t\treturn node.getDimensions();\n\t}\n\tif (\n\t\tnode === window ||\n\t\tnode === document.documentElement ||\n\t\tnode === document.body\n\t) {\n\t\treturn {\n\t\t\ttop: 0,\n\t\t\tright: document.documentElement.clientWidth,\n\t\t\tbottom: document.documentElement.clientHeight,\n\t\t\tleft: 0,\n\t\t\twidth: document.documentElement.clientWidth,\n\t\t\theight: document.documentElement.clientHeight,\n\t\t\texisting: {\n\t\t\t\ttop: 0,\n\t\t\t\tleft: 0\n\t\t\t},\n\t\t\tscroll: {\n\t\t\t\tblock: window.scrollY,\n\t\t\t\tinline: window.scrollX,\n\t\t\t\theight: document.documentElement.scrollHeight,\n\t\t\t\twidth: document.documentElement.scrollWidth\n\t\t\t}\n\t\t};\n\t}\n\n\t// the fractional part of the getBoundingClientRect() values may cause\n\t// subtle differences to the rendered position after fit is run, which can\n\t// be pretty noticeable if we're constantly updating the fit position on\n\t// scroll. Rounding here helps to avoid this jitteriness.\n\tconst box = node.getBoundingClientRect();\n\tconst top = Math.round(box.top);\n\tconst right = Math.round(box.right);\n\tconst bottom = Math.round(box.bottom);\n\tconst left = Math.round(box.left);\n\tconst width = Math.round(box.width);\n\tconst height = Math.round(box.height);\n\tconst {scrollWidth, scrollHeight, scrollTop, scrollLeft} = node;\n\tconst style = window.getComputedStyle(node);\n\treturn {\n\t\ttop,\n\t\tright,\n\t\tbottom,\n\t\tleft,\n\t\twidth,\n\t\theight,\n\t\texisting: {\n\t\t\ttop: parseInt(style.top, 10) || 0,\n\t\t\tleft: parseInt(style.left, 10) || 0\n\t\t},\n\t\tscroll: {\n\t\t\t// scrollWidth/height might be smaller than the getBoundingClientRect\n\t\t\t// reported values because scrollWidth/height returns rounded, whole\n\t\t\t// numbers and getBoundingClientRect returns fractions. However, we treat\n\t\t\t// these scroll properties as the largest possible size that the node can\n\t\t\t// take up, so we want to guarantee that these properties are always at\n\t\t\t// least the size of the getBoundingClientRect width/height.\n\t\t\twidth: canScroll(style.overflowX) ? Math.max(scrollWidth, width) : width,\n\t\t\theight: canScroll(style.overflowY)\n\t\t\t\t? Math.max(scrollHeight, height)\n\t\t\t\t: height,\n\t\t\tblock: scrollTop,\n\t\t\tinline: scrollLeft\n\t\t}\n\t};\n}\n","import calculateContentAreaDimensions from './content-area';\nimport calculateContentAreaStyles from './content-area-styles';\nimport calculateContentDimensions from './content';\nimport calculateContentStyles from './content-styles';\nimport calculateOverlap from './overlap';\nimport {normalizeConstrain, applyConstrain} from './constrain';\n\n/**\n * Offset used to take an array of 6 values.\n * If someone passes in 6 values we will take the last four and apply them to the normOffset.\n * The functionality of this has not changed from V1.\n * We not longer support the first two values of the 6 value array. They didn't work as intended.\n * Instead we will convert the old two values to our new one value.\n */\nconst makeOffsetBackwardsCompatible = (offset) => {\n\tif (offset.length === 6) {\n\t\treturn offset.slice(2, 6);\n\t} else {\n\t\treturn offset.find((element) => element > 0);\n\t}\n};\n\n/**\n * Normalizes the offset format into `[top, end, bottom, start]`\n */\nconst normalizeOffset = (offset, targetPosition, contentPosition) => {\n\tlet value = offset;\n\tif (Array.isArray(offset)) {\n\t\tconst backwardCompatibleOffset = makeOffsetBackwardsCompatible(offset);\n\t\tif (Array.isArray(backwardCompatibleOffset)) {\n\t\t\treturn backwardCompatibleOffset;\n\t\t} else value = backwardCompatibleOffset;\n\t}\n\n\tlet calcOffset = [value, value, value, value];\n\tif (targetPosition[0] === contentPosition[0]) {\n\t\tcalcOffset[0] = 0;\n\t\tcalcOffset[2] = 0;\n\t}\n\tif (targetPosition[1] === contentPosition[1]) {\n\t\tcalcOffset[1] = 0;\n\t\tcalcOffset[3] = 0;\n\t}\n\treturn calcOffset;\n};\n\n/**\n * Adds the offset to the target dimensions for positioning\n * @param {Dimensions} targetDimensions - Target dimensions\n * @param {Array<number>} normOffset - normalized offset into `[top, right, bottom, left]` format\n * @returns {Dimensions} - new dimensions with the normalized offset added in\n */\nfunction addOffsetPaddingToDimensions(targetDimensions, normOffset) {\n\tconst [top = 0, right = 0, bottom = 0, left = 0] = normOffset;\n\treturn {\n\t\t...targetDimensions,\n\t\ttop: targetDimensions.top - top,\n\t\tright: targetDimensions.right + right,\n\t\tbottom: targetDimensions.bottom + bottom,\n\t\tleft: targetDimensions.left - left,\n\t\twidth: targetDimensions.width + left + right,\n\t\theight: targetDimensions.height + top + bottom\n\t};\n}\n\n/**\n * Calculates dimensions for the content area and position of the content.\n * Returns the styles for the content area and the content, as well as a ratio\n * of how much of the content has been adjusted and/or is hidden by scrolling.\n * @param {Dimensions} targetDimensions - Target dimensions object\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} contentAreaDimensions - Content area dimensions object\n * @param {Dimensions} containerDimensions - Container dimensions object\n * @param {Dimensions} viewportDimensions - Viewport dimensions object\n * @param {Origin[]} targetPosition\n * @param {Origin[]} contentPosition\n * @param {number} offset - Amount to offset content from the target\n * @param {Constrain} constrain - Constrain configuration\n */\nexport default function calculateFit(\n\ttargetDimensions,\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tcontainerDimensions,\n\tviewportDimensions,\n\ttargetPosition,\n\tcontentPosition,\n\toffset,\n\tconstrain\n) {\n\tconst normOffset = normalizeOffset(offset, targetPosition, contentPosition);\n\tconst normConstrain = normalizeConstrain(\n\t\tconstrain,\n\t\ttargetDimensions,\n\t\tcontentDimensions\n\t);\n\n\tconst constrainedContentDimensions = applyConstrain(\n\t\tnormConstrain,\n\t\tcontentDimensions\n\t);\n\n\tconst paddedTargetDimensions = addOffsetPaddingToDimensions(\n\t\ttargetDimensions,\n\t\tnormOffset\n\t);\n\n\tconst nextContentAreaDimensions = calculateContentAreaDimensions(\n\t\tpaddedTargetDimensions,\n\t\tconstrainedContentDimensions,\n\t\tcontentAreaDimensions,\n\t\tcontainerDimensions,\n\t\ttargetPosition,\n\t\tcontentPosition\n\t);\n\n\t// updated content dimensions and overlap is only used to determine how much\n\t// of the content is actually going to be visible. We'll compare these values\n\t// when determining the best fit. These values are not necessary to calculate\n\t// the final CSS for the content element.\n\n\tconst nextContentDimensions = calculateContentDimensions(\n\t\tconstrainedContentDimensions,\n\t\tnextContentAreaDimensions,\n\t\tcontentPosition\n\t);\n\n\tconst {visibleContentDimensions, overlapRatios} = calculateOverlap(\n\t\tnextContentDimensions,\n\t\tnextContentAreaDimensions,\n\t\tviewportDimensions\n\t);\n\n\tconst contentAreaStyles = calculateContentAreaStyles(\n\t\tcontentAreaDimensions,\n\t\tnextContentAreaDimensions\n\t);\n\tconst contentStyles = calculateContentStyles(contentPosition, normConstrain);\n\n\treturn {\n\t\tstyle: {\n\t\t\tcontentArea: contentAreaStyles,\n\t\t\tcontent: contentStyles\n\t\t},\n\t\tdimensions: {\n\t\t\ttarget: targetDimensions,\n\t\t\tcontent: visibleContentDimensions,\n\t\t\tcontentArea: nextContentAreaDimensions,\n\t\t\tcontainer: containerDimensions\n\t\t},\n\t\toverlapRatios,\n\t\ttargetPosition,\n\t\tcontentPosition\n\t};\n}\n","import getAxisInfo from './get-axis-info';\n\n/**\n * Calculates either the height or width based on the target and content\n * position and dimensions.\n * @param {Dimensions} targetDimensions - Target dimensions object plus offsets\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} containerDimensions - Container dimensions object\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} targetPosition - Logical target position\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} contentPosition - Logical content position\n * @param {(\"block\"|\"inline\")} axis - Axis that is being calculated (block for top/bottom, inline for left/right)\n * @return {number} - the calculated width or height of the content area\n */\nexport function calculateContentAreaLength(\n\ttargetDimensions,\n\tcontentDimensions,\n\tcontainerDimensions,\n\ttargetPosition,\n\tcontentPosition,\n\taxis\n) {\n\tconst {topOrLeft, widthOrHeight} = getAxisInfo(axis);\n\n\t// edge case: if centered content is bigger than the container, we want\n\t// contentArea to fill the entire container.\n\tif (\n\t\tcontentPosition === 'center' &&\n\t\tcontentDimensions[widthOrHeight] >=\n\t\t\tcontainerDimensions.scroll[widthOrHeight]\n\t) {\n\t\treturn containerDimensions.scroll[widthOrHeight];\n\t}\n\n\tconst targetOffsetContainerTopOrLeft =\n\t\ttargetDimensions[topOrLeft] -\n\t\tcontainerDimensions[topOrLeft] +\n\t\tcontainerDimensions.scroll[axis];\n\n\t// Initial length is the distance between the top/left of the container and\n\t// the target\n\tlet length = targetOffsetContainerTopOrLeft;\n\n\t// Adjust a little bit based on the alignment of the target\n\tif (targetPosition === 'center') {\n\t\tlength += targetDimensions[widthOrHeight] / 2;\n\t} else if (targetPosition === 'bottom' || targetPosition === 'end') {\n\t\tlength += targetDimensions[widthOrHeight];\n\t}\n\n\t// For start/center positions, we want contentArea to grow down/right from\n\t// the target, so we really need whatever space is remaining compared to above\n\tif (\n\t\tcontentPosition === 'top' ||\n\t\tcontentPosition === 'start' ||\n\t\tcontentPosition === 'center'\n\t) {\n\t\tlength = containerDimensions.scroll[widthOrHeight] - length;\n\n\t\t// Centered is a little special: we want to keep 50% of the content on\n\t\t// either side of the target\n\t\tif (contentPosition === 'center') {\n\t\t\tlength += contentDimensions[widthOrHeight] / 2;\n\t\t}\n\t}\n\n\t// ensure contentArea is never bigger than the container, and is always\n\t// a whole number.\n\treturn Math.floor(\n\t\tMath.min(length, containerDimensions.scroll[widthOrHeight])\n\t);\n}\n\n/**\n * Calculates either the top or left offset based on the target and content\n * positions and dimensions.\n * @param {Dimensions} targetDimensions - Target dimensions object plus offsets\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} contentAreaDimensions - Content area dimensions object\n * @param {Dimensions} containerDimensions - Container dimensions object\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} targetPosition - Logical target position\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} contentPosition - Logical content position\n * @param {(\"block\"|\"inline\")} axis - Axis that is being calculated (block for top/bottom, inline for left/right)\n * @return {number} - the calculated offset top or left of the content area\n */\nexport function calculateContentAreaOffset(\n\ttargetDimensions,\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tcontainerDimensions,\n\ttargetPosition,\n\tcontentPosition,\n\taxis\n) {\n\tconst {topOrLeft, widthOrHeight} = getAxisInfo(axis);\n\n\t// With absolute positioning, contentArea could start at any point inside the\n\t// container. Need to figure out the amount to shift the contentArea so that\n\t// it aligns to the container properly.\n\t//\n\t// Start by figuring out how to get the contentArea position to align\n\t// to the top/start of the container:\n\tlet calcOffset =\n\t\t// Start with container's current position\n\t\tcontainerDimensions[topOrLeft] -\n\t\t// Add the scrolling offset. Dimensions values are relative to the\n\t\t// viewport, which doesn't know about any scrolling offset introduced by an\n\t\t// overflow'able container.\n\t\tcontainerDimensions.scroll[axis];\n\n\t// If contentArea is already stretched to be as big as the container, then we don't\n\t// need to do any other adjusting.\n\tif (\n\t\tcontentAreaDimensions[widthOrHeight] <\n\t\tcontainerDimensions.scroll[widthOrHeight]\n\t) {\n\t\t// When content is top or start aligned, the content area starts at the\n\t\t// target position and grows towards the bottom/end of the container. Need\n\t\t// to increase the `calcOffset` by however much the target offset is.\n\t\t//\n\t\t// We'll skip over this adjustment in the case where content is bottom/end\n\t\t// aligned, because in these cases the contentArea starts at the top/start\n\t\t// point of the container, which we already figured out above.\n\t\tif (\n\t\t\tcontentPosition === 'top' ||\n\t\t\tcontentPosition === 'start' ||\n\t\t\tcontentPosition === 'center'\n\t\t) {\n\t\t\tcalcOffset +=\n\t\t\t\ttargetDimensions[topOrLeft] -\n\t\t\t\tcontainerDimensions[topOrLeft] +\n\t\t\t\tcontainerDimensions.scroll[axis];\n\n\t\t\t// Centered is a little special: we want to keep 50% of the content on\n\t\t\t// either side of the target\n\t\t\tif (contentPosition === 'center') {\n\t\t\t\tcalcOffset -= contentDimensions[widthOrHeight] / 2;\n\t\t\t}\n\n\t\t\t// Adjust a little bit based on the alignment of the target\n\t\t\tif (targetPosition === 'center') {\n\t\t\t\tcalcOffset += targetDimensions[widthOrHeight] / 2;\n\t\t\t} else if (targetPosition === 'bottom' || targetPosition === 'end') {\n\t\t\t\tcalcOffset += targetDimensions[widthOrHeight];\n\t\t\t}\n\t\t}\n\t}\n\n\treturn Math.floor(calcOffset);\n}\n\n/**\n * Calculates a new dimensions object that describes the desired contentArea\n * size and position after it is placed relative to the target.\n * @param {Dimensions} targetDimensions - Target dimensions object plus offsets\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} contentAreaDimensions - Content area dimensions object\n * @param {Dimensions} containerDimensions - Container dimensions object\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} targetPosition - Logical target position\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} contentPosition - Logical content position\n * @return {Dimensions} - a new content area dimensions object\n */\nexport default function calculateContentAreaDimensions(\n\ttargetDimensions,\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tcontainerDimensions,\n\ttargetPosition,\n\tcontentPosition\n) {\n\tconst [targetPositionBlock, targetPositionInline] = targetPosition;\n\tconst [contentPositionBlock, contentPositionInline] = contentPosition;\n\n\tconst nextContentAreaDimensions = {...contentAreaDimensions};\n\tnextContentAreaDimensions.width = calculateContentAreaLength(\n\t\ttargetDimensions,\n\t\tcontentDimensions,\n\t\tcontainerDimensions,\n\t\ttargetPositionInline,\n\t\tcontentPositionInline,\n\t\t'inline'\n\t);\n\n\tnextContentAreaDimensions.height = calculateContentAreaLength(\n\t\ttargetDimensions,\n\t\tcontentDimensions,\n\t\tcontainerDimensions,\n\t\ttargetPositionBlock,\n\t\tcontentPositionBlock,\n\t\t'block'\n\t);\n\n\tnextContentAreaDimensions.left = calculateContentAreaOffset(\n\t\ttargetDimensions,\n\t\tcontentDimensions,\n\t\tnextContentAreaDimensions,\n\t\tcontainerDimensions,\n\t\ttargetPositionInline,\n\t\tcontentPositionInline,\n\t\t'inline'\n\t);\n\n\tnextContentAreaDimensions.top = calculateContentAreaOffset(\n\t\ttargetDimensions,\n\t\tcontentDimensions,\n\t\tnextContentAreaDimensions,\n\t\tcontainerDimensions,\n\t\ttargetPositionBlock,\n\t\tcontentPositionBlock,\n\t\t'block'\n\t);\n\n\tnextContentAreaDimensions.right =\n\t\tnextContentAreaDimensions.left + nextContentAreaDimensions.width;\n\tnextContentAreaDimensions.bottom =\n\t\tnextContentAreaDimensions.top + nextContentAreaDimensions.height;\n\n\treturn nextContentAreaDimensions;\n}\n","/**\n * Creates an object of CSS properties to be applied to the contentArea element\n * @param {Dimensions} contentAreaDimensions - the current contentArea dimensions object,\n * before any fit calculations have been applied.\n * @param {Dimensions} nextContentAreaDimensions - the new contentArea dimensions object,\n * after all fit calculations have been applied.\n * @returns {Object} CSS properties that should be applied to contentArea.\n */\nexport default function calculateContentAreaStyles(\n\tcontentAreaDimensions,\n\tnextContentAreaDimensions\n) {\n\t// determine the distance we need to move the old contentArea to correctly\n\t// match the new contentArea. Since we're going to be setting these as inline\n\t// styles, we need to make sure we also consider any existing inline style\n\t// values for top and left, as these will get overwritten:\n\t//\n\t//\tExample, if we have the following, relative to the top of the page:\n\t//\n\t//\t\t<div id=\"content-area\" style=\"top: 20px; left: 20px\" />\n\t//\n\t//  And we want to position this contentArea to start at point (30, 30),\n\t//  our dimensions objects look like:\n\t//\n\t//\t\t    contentAreaDimensions = { top: 20, left: 20 };\n\t//\t\tnextContentAreaDimensions = { top: 30, left: 30 };\n\t//\n\t//  If we don't account for the existing inline styles, we would assume that\n\t//  we only need to move the contentArea 10px top and left, so we'd result\n\t//  in:\n\t//\n\t//\t\t<div id=\"content-area\" style=\"top: 10px; left: 10px\" />\n\t//\n\t//\twhich is not correct. We need to make sure we also factor in the existing\n\t//\t20px top/left that the contentArea started with. These values are tracked\n\t//\tin the `existing` property of a dimensions object:\n\tconst top =\n\t\tnextContentAreaDimensions.top -\n\t\tcontentAreaDimensions.top +\n\t\tcontentAreaDimensions.existing.top;\n\tconst left =\n\t\tnextContentAreaDimensions.left -\n\t\tcontentAreaDimensions.left +\n\t\tcontentAreaDimensions.existing.left;\n\treturn {\n\t\ttop: `${top}px`,\n\t\tleft: `${left}px`,\n\t\twidth: `${nextContentAreaDimensions.width}px`,\n\t\theight: `${nextContentAreaDimensions.height}px`,\n\t\tposition: 'absolute',\n\t\tpointerEvents: 'none'\n\t};\n}\n","import getAxisInfo from './get-axis-info';\n\n/**\n * Calculates either the top or left coordinate for the content based on where\n * it would exist when placed in the new content area.\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} contentAreaDimensions - Content area dimensions object\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} contentPosition - Logical content position\n * @param {(\"block\"|\"inline\")} axis - Axis that is being calculated (block for top/bottom, inline for left/right)\n * @return {number} - the calculated offset top or left of the content area\n */\nexport function calculateContentOffset(\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tcontentPosition,\n\taxis\n) {\n\tconst {topOrLeft, bottomOrRight, widthOrHeight} = getAxisInfo(axis);\n\tif (\n\t\tcontentPosition === 'top' ||\n\t\tcontentPosition === 'start' ||\n\t\tcontentPosition === 'center'\n\t) {\n\t\treturn contentAreaDimensions[topOrLeft];\n\t}\n\n\treturn (\n\t\tcontentAreaDimensions[bottomOrRight] - contentDimensions[widthOrHeight]\n\t);\n}\n\n/**\n * Calculates a new content dimensions object that describes where\n * the content would be after being placed inside the (correctly-positioned)\n * content area.\n *\n * Note that these values aren't necessarily the final values where content is\n * going to be rendered. It is the point where content would be if there were\n * no other boundaries (from the viewport, container, or both). This is useful\n * later to determine how much of the content will be visible and rank this\n * position against others in `getBestFitInfo`.\n *\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} contentAreaDimensions - Content area dimensions object\n * @param {(\"top\"|\"start\"|\"center\"|\"bottom\"|\"end\")} contentPosition - Logical content position\n * @param {(\"block\"|\"inline\")} axis - Axis that is being calculated (block for top/bottom, inline for left/right)\n * @return {Dimensions} - the updated content dimensions object as if it were placed\n * in a correctly-positioned contentArea and not bounded by any other containing object.\n */\nexport default function calculateContentDimensions(\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tcontentPosition\n) {\n\tconst [contentPositionBlock, contentPositionInline] = contentPosition;\n\n\tconst nextContentDimensions = {...contentDimensions};\n\n\tnextContentDimensions.top = calculateContentOffset(\n\t\tcontentDimensions,\n\t\tcontentAreaDimensions,\n\t\tcontentPositionBlock,\n\t\t'block'\n\t);\n\n\tnextContentDimensions.left = calculateContentOffset(\n\t\tcontentDimensions,\n\t\tcontentAreaDimensions,\n\t\tcontentPositionInline,\n\t\t'inline'\n\t);\n\n\tnextContentDimensions.bottom =\n\t\tnextContentDimensions.top + contentDimensions.height;\n\tnextContentDimensions.right =\n\t\tnextContentDimensions.left + contentDimensions.width;\n\n\treturn nextContentDimensions;\n}\n","/**\n * Calculates constrain styles based on developer-specified configuration.\n */\nexport function getConstrainStyles(constrain) {\n\treturn Object.entries(constrain).reduce((result, [key, value]) => {\n\t\tresult[key] = `${value}px`;\n\t\treturn result;\n\t}, {});\n}\n\n/**\n * Calculates and returns styles to be applied to the content.\n * @param {Object} contentStyles - Other content styles to apply\n * @param {Object} contentPosition - position of content\n * @return {Object}\n */\nexport function addCSSProperties(contentStyles, contentPosition) {\n\tconst isBottomAligned = contentPosition[0] === 'bottom';\n\tconst isEndAligned = contentPosition[1] === 'end';\n\n\treturn {\n\t\t...contentStyles,\n\t\ttop: isBottomAligned ? 'unset' : '0px',\n\t\tbottom: isBottomAligned ? '0px' : 'unset',\n\t\tleft: isEndAligned ? 'unset' : '0px',\n\t\tright: isEndAligned ? '0px' : 'unset',\n\t\tposition: 'absolute',\n\t\tpointerEvents: 'initial'\n\t};\n}\n\n/**\n * Calculates and returns styles to be applied to the content.\n * @param {Position} contentPosition - Logical position for the content\n * @param {Constrain} constrain - normalized contrain configuration object\n * @return {Object} a set of CSS properties that should be applied to the\n * content element.\n */\nexport default function calculateContentStyles(contentPosition, constrain) {\n\tconst contentStyles = getConstrainStyles(constrain);\n\treturn addCSSProperties(contentStyles, contentPosition);\n}\n","/**\n * Restricts the content dimensions to the given bounding dimensions object\n * and returns both the ratio of overlap and the new dimensions.\n *\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} boundingDimensions - container dimensions or viewport dimensions, depending\n * on which bounding element to compare to.\n * @returns {{ratio: number, dimensions: Dimensions}}\n */\nexport function restrictToBoundingBox(contentDimensions, boundingDimensions) {\n\tconst fullyVisible =\n\t\tcontentDimensions.top >= boundingDimensions.top &&\n\t\tcontentDimensions.right <= boundingDimensions.right &&\n\t\tcontentDimensions.bottom <= boundingDimensions.bottom &&\n\t\tcontentDimensions.left >= boundingDimensions.left;\n\n\tif (fullyVisible) {\n\t\treturn {\n\t\t\tratio: 1,\n\t\t\tdimensions: contentDimensions\n\t\t};\n\t}\n\n\tconst visibleDimensions = {\n\t\t...contentDimensions,\n\t\tleft: Math.max(contentDimensions.left, boundingDimensions.left),\n\t\tright: Math.min(contentDimensions.right, boundingDimensions.right),\n\t\tbottom: Math.min(contentDimensions.bottom, boundingDimensions.bottom),\n\t\ttop: Math.max(contentDimensions.top, boundingDimensions.top)\n\t};\n\n\tvisibleDimensions.width = visibleDimensions.right - visibleDimensions.left;\n\tvisibleDimensions.height = visibleDimensions.bottom - visibleDimensions.top;\n\tconst actualArea = visibleDimensions.width * visibleDimensions.height;\n\tconst wantedArea = contentDimensions.width * contentDimensions.height;\n\n\treturn {\n\t\tratio: actualArea / wantedArea,\n\t\tdimensions: visibleDimensions\n\t};\n}\n\n/**\n * Calculates how much of the content would actually be viewable for the\n * given container and viewport.\n *\n * @param {Dimensions} contentDimensions - Content dimensions object\n * @param {Dimensions} containerDimensions - Container dimensions object\n * @param {Dimensions} viewportDimensions - Viewport dimensions object\n *\n * @typedef {Object} Overlap an object describing how much the content overlaps\n * with other boundary containers\n * @param {object} overlapRatios Object containing overlap ratios for the\n * container and viewport.\n * @param {number} overlapRatios.container The ratio of content that overlaps with the\n * container element. If the content completely fits in the container, this\n * value will be `1`. If the content falls off the container, this value will\n * be between 0 and 1.\n * @param {number} overlapRatios.viewport The ratio of content that overlaps with the\n * viewport element. If the content completely fits in the viewport, this\n * value will be `1`. If the content falls off the container, this value will\n * be between 0 and 1.\n * @param {Dimensions} visibleContentDimensions Updated content dimensions that\n * are bounded by the container. If the content fits completely in the container,\n * these dimensions will be identical to the original content dimensions. If the content\n * falls out of the container, then this dimensions object will be the overlap between\n * the content and the container.\n * @return {Overlap}\n */\nexport default function calculateOverlap(\n\tcontentDimensions,\n\tcontentAreaDimensions,\n\tviewportDimensions\n) {\n\tconst contentInContainer = restrictToBoundingBox(\n\t\tcontentDimensions,\n\t\tcontentAreaDimensions\n\t);\n\tconst contentInViewport = restrictToBoundingBox(\n\t\tcontentDimensions,\n\t\tviewportDimensions\n\t);\n\n\treturn {\n\t\toverlapRatios: {\n\t\t\tcontainer: contentInContainer.ratio,\n\t\t\tviewport: contentInViewport.ratio\n\t\t},\n\t\tvisibleContentDimensions: contentInContainer.dimensions\n\t};\n}\n","import toSizeValue from './to-size-value';\n\n/**\n * Returns the dimension direction for a given constrain\n * key.\n * @returns {(\"width\"|\"height\"|null)} returns \"width\" for width-related keys,\n * \"height\" for height-related keys, and null for any invalid key\n */\nexport function getDimensionForConstrainKey(key) {\n\tif (['width', 'minWidth', 'maxWidth'].includes(key)) {\n\t\treturn 'width';\n\t}\n\n\tif (['height', 'minHeight', 'maxHeight'].includes(key)) {\n\t\treturn 'height';\n\t}\n\n\treturn null;\n}\n\n/**\n * Normalizes a constrain configuration by mapping all special keywords\n * (`auto`, `target`), etc to resolved numerical values. Also drops\n * any property keys that are not valid\n *\n * @param {Constrain} constrain - constrain object before normalization\n * @param {Dimensions} targetDimensions - target dimensions object\n * @param {Dimensions} contentDimensions - content dimensions object\n */\nexport function normalizeConstrain(\n\tconstrain,\n\ttargetDimensions,\n\tcontentDimensions\n) {\n\treturn Object.entries(constrain).reduce((result, [key, constraint]) => {\n\t\tconst widthOrHeight = getDimensionForConstrainKey(key);\n\t\tif (widthOrHeight) {\n\t\t\tresult[key] = toSizeValue(\n\t\t\t\tcontentDimensions.scroll[widthOrHeight],\n\t\t\t\ttargetDimensions[widthOrHeight],\n\t\t\t\tconstraint\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}, {});\n}\n\n/**\n * Returns a new dimensions object with the constrain values applied.\n *\n * @param {Constrain} normalizedConstrain - constrain object after normalization\n * @param {Dimensions} dimensions - dimensions object to apply constrain to\n */\nexport function applyConstrain(normalizedConstrain, dimensions) {\n\tconst newDimensions = Object.entries(normalizedConstrain).reduce(\n\t\t(result, [key, value]) => {\n\t\t\tconst widthOrHeight = getDimensionForConstrainKey(key);\n\t\t\tif (key.startsWith('min')) {\n\t\t\t\tresult[widthOrHeight] = Math.max(dimensions[widthOrHeight], value);\n\t\t\t} else if (key.startsWith('max')) {\n\t\t\t\tresult[widthOrHeight] = Math.min(dimensions[widthOrHeight], value);\n\t\t\t} else {\n\t\t\t\tresult[widthOrHeight] = value;\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\t\t{...dimensions}\n\t);\n\n\tnewDimensions.bottom = newDimensions.top + newDimensions.height;\n\tnewDimensions.right = newDimensions.left + newDimensions.width;\n\n\treturn newDimensions;\n}\n","/**\n * Calculates special values of `constrain`\n */\nexport default function toSizeValue(contentValue, targetValue, constrainValue) {\n\tif (constrainValue === 'auto') {\n\t\treturn contentValue;\n\t}\n\tif (constrainValue === 'target') {\n\t\treturn targetValue;\n\t}\n\tif (typeof constrainValue === 'number') {\n\t\treturn constrainValue;\n\t}\n\tthrow new Error('Sizing value is not valid');\n}\n","import getAxisInfo from './get-axis-info';\n\nfunction isVisible(axis, position, targetRect, intersectionRect) {\n\tconst {topOrLeft, bottomOrRight, widthOrHeight} = getAxisInfo(axis);\n\n\t// When centered, we want to make sure that the size of the intersection is\n\t// at least as long as half of the target\n\tif (position === 'center') {\n\t\treturn (\n\t\t\tintersectionRect[bottomOrRight] - intersectionRect[topOrLeft] >=\n\t\t\ttargetRect[widthOrHeight] / 2\n\t\t);\n\t}\n\n\t// Otherwise we just need to check that the intersection starts/ends in the\n\t// same place that our target does.\n\t//\n\t// (╯°□°）╯︵┻━┻ Safari will return fractional pixels for the targetRect, but\n\t// not for the intersectionRect, so it's possible for these numbers to be\n\t// slightly different\n\treturn (\n\t\tMath.round(targetRect[position]) === Math.round(intersectionRect[position])\n\t);\n}\n\n/**\n * Checks to see if the origin point of a target element is visible based on\n * the fit position.\n * @param targetPosition {Array<string>} the target's fit position\n * @param entry {IntersectionObserverEntry} an entry that is created by an IntersectionObserver\n *\n * @returns {boolean} true when the origin point of the entry is still visible\n */\nexport default function isTargetVisible(targetPosition, entry) {\n\tconst {\n\t\tintersectionRatio,\n\t\tboundingClientRect: targetRect,\n\t\tintersectionRect\n\t} = entry;\n\n\t// 0% of the target is visible\n\tif (intersectionRatio === 0) {\n\t\treturn false;\n\t}\n\n\t// 100% of the target is visible\n\tif (intersectionRatio === 1) {\n\t\treturn true;\n\t}\n\n\tconst blockPosition = targetPosition[0];\n\tconst inlinePosition = targetPosition[1]\n\t\t.replace('start', 'left') // convert start/end to left/right so that these values\n\t\t.replace('end', 'right'); // match up with the properties we get in a DOMRect\n\n\treturn (\n\t\tisVisible('block', blockPosition, targetRect, intersectionRect) &&\n\t\tisVisible('inline', inlinePosition, targetRect, intersectionRect)\n\t);\n}\n","module.exports = __TECTONIC__lodash_4_17_4[\"isEqual\"];","module.exports = __TECTONIC__lodash_4_17_4[\"once\"];","module.exports = __TECTONIC__lodash_4_17_4[\"noop\"];","const TAIL_LENGTH = 20;\n\nexport default function setTailPosition({\n\tpanel,\n\tcontentArea,\n\ttargetDimensions,\n\tcontentAreaDimensions,\n\ttargetPosition,\n\tcontentPosition\n}) {\n\tconst {offset, direction} = getTailPosition({\n\t\ttargetDimensions,\n\t\tcontentAreaDimensions,\n\t\ttargetPosition,\n\t\tcontentPosition\n\t});\n\n\tcontentArea.style.setProperty('--popover-tail', `${offset}px`);\n\tpanel.tailDirection = direction;\n}\n\nexport function getTailPosition({\n\ttargetDimensions,\n\tcontentAreaDimensions,\n\ttargetPosition,\n\tcontentPosition\n}) {\n\tif (\n\t\t(targetPosition[0] === 'bottom' && contentPosition[0] === 'top') ||\n\t\t(targetPosition[0] === 'top' && contentPosition[0] === 'bottom')\n\t) {\n\t\tconst middleOfTarget = targetDimensions.width / 2;\n\t\tconst deltaX = targetDimensions.left - contentAreaDimensions.left;\n\t\treturn {\n\t\t\tdirection: targetPosition[0] === 'top' ? 'down' : 'up',\n\t\t\toffset: deltaX + middleOfTarget - TAIL_LENGTH / 2\n\t\t};\n\t}\n\n\tif (\n\t\t(targetPosition[1] === 'start' && contentPosition[1] === 'end') ||\n\t\t(targetPosition[1] === 'end' && contentPosition[1] === 'start')\n\t) {\n\t\tconst middleOfTarget = targetDimensions.height / 2;\n\t\tconst deltaY = targetDimensions.top - contentAreaDimensions.top;\n\t\treturn {\n\t\t\tdirection: targetPosition[1] === 'start' ? 'right' : 'left',\n\t\t\toffset: deltaY + middleOfTarget - TAIL_LENGTH / 2\n\t\t};\n\t}\n\n\treturn null;\n}\n","module.exports = __TECTONIC__lodash_4_17_4[\"find\"];","import {\n\tfindTabbableNodes,\n\tgetActiveElement\n} from '@servicenow/library-enhanced-utils';\nimport inRange from 'lodash/inRange';\n\n// JS `%` doesn't work with negative numbers :(\nfunction mod(n, m) {\n\treturn ((n % m) + m) % m;\n}\n\nexport function focusFirstItemInPanel(panel) {\n\tconst firstFocusableElement = findNextFocusTarget({\n\t\twithin: panel,\n\t\tcurrent: null\n\t});\n\n\tif (firstFocusableElement) {\n\t\tfirstFocusableElement.focus();\n\t}\n}\n\nexport function findNextFocusTarget({\n\twithin = document.body,\n\tcurrent = getActiveElement(),\n\twrap = true,\n\tshiftKey = false\n}) {\n\tif (!within) {\n\t\treturn null;\n\t}\n\n\tconst delta = shiftKey ? -1 : 1;\n\tconst tabbableNodes = findTabbableNodes(within);\n\tconst currentIndex = tabbableNodes.indexOf(current);\n\tconst needsWrap = !inRange(currentIndex + delta, 0, tabbableNodes.length);\n\tif (needsWrap && !wrap) {\n\t\treturn null;\n\t}\n\n\tconst nextIndex = mod(currentIndex + delta, tabbableNodes.length);\n\tconst next = tabbableNodes[nextIndex];\n\treturn next || null;\n}\n","module.exports = __TECTONIC__lodash_4_17_4[\"inRange\"];","import isEmpty from 'lodash/isEmpty';\nimport forEachRight from 'lodash/forEachRight';\nimport debounce from 'lodash/debounce';\n\n/**\n * Factory function to provide a way to have multiple callbacks triggered from\n * a single (optionally debounced) DOM event listener on the window.\n *\n * This has a couple of benefits over direct `addEventListeners`\n *\n * - Re-using a single event listener to run multiple callbacks leads to a\n *   performance gain in Chrome + Safari (Firefox doesn't seem to care much)\n *\n * - Callbacks can be deleted just by just ID, rather than needing to maintain\n *   a reference to the callback that was used in `addEventListener`\n *\n * - We can easily guarantee execution order when multiple instances listen\n *   to the same event.\n *\n * Callbacks are run in reverse order, so newer callbacks happen first. If any\n * callback returns an explicit `false`, other callbacks are not run.\n */\nexport default function createBatchedListener(eventType, {batch = false} = {}) {\n\tconst callbacks = {};\n\n\tlet runCallbacks = (event) =>\n\t\tforEachRight(callbacks, (callback) => callback(event));\n\tif (batch) {\n\t\trunCallbacks = debounce(runCallbacks, 500);\n\t}\n\n\treturn {\n\t\tadd(id, callback) {\n\t\t\tconst needsToAttach = isEmpty(callbacks);\n\t\t\tcallbacks[id] = callback;\n\n\t\t\tif (needsToAttach) {\n\t\t\t\twindow.addEventListener(eventType, runCallbacks, true);\n\t\t\t}\n\t\t},\n\n\t\tremove(id) {\n\t\t\tdelete callbacks[id];\n\t\t\tconst canDetach = isEmpty(callbacks);\n\n\t\t\tif (canDetach) {\n\t\t\t\twindow.removeEventListener(eventType, runCallbacks, true);\n\t\t\t}\n\t\t}\n\t};\n}\n","module.exports = __TECTONIC__lodash_4_17_4[\"forEachRight\"];","module.exports = __TECTONIC__lodash_4_17_4[\"debounce\"];","/**\n * Sets up an Observer that calls the given callback\n */\nexport default function createObserver(Observer) {\n\tconst observed = new Map();\n\n\treturn {\n\t\tadd(id, target, callback, ...observerArgs) {\n\t\t\tconst observer = new Observer(callback, ...observerArgs);\n\t\t\tobserver.observe(target);\n\t\t\tobserved.set(id, {observer, target});\n\t\t},\n\n\t\tremove(id) {\n\t\t\tconst value = observed.get(id);\n\t\t\tif (!value) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {observer, target} = value;\n\n\t\t\tobserver.unobserve(target);\n\t\t\tobserved.delete(id);\n\t\t}\n\t};\n}\n","import {findAncestors} from './dom';\n\n/**\n * Attaches scroll listeners to all ancestor elements of the given host element\n * that have shadow roots (because scroll events do not automatically bubble\n * through shadow boundaries). When any of the scroll listeners are fired,\n * trigger the callback function.\n * @param {HTMLElement} host\n * @param {string} componentId\n * @param {function} callback\n */\nexport default function createScrollListener() {\n\tconst attached = new Map();\n\n\treturn {\n\t\tasync add(id, host, container, callback) {\n\t\t\tconst ancestors = await findAncestors(id, host, container);\n\t\t\tconst targets = [];\n\t\t\tancestors.forEach((el) => el.shadowRoot && targets.push(el));\n\n\t\t\tconst listener = (e) => {\n\t\t\t\tconst [source] = e.composedPath();\n\t\t\t\tif (ancestors.has(source)) {\n\t\t\t\t\tcallback(e);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.shadowRoot.addEventListener('scroll', listener, true);\n\t\t\t}\n\n\t\t\tattached.set(id, {targets, listener});\n\t\t},\n\t\tremove(id) {\n\t\t\tconst value = attached.get(id);\n\t\t\tif (!value) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst {targets, listener} = value;\n\t\t\tfor (const target of targets) {\n\t\t\t\ttarget.shadowRoot.removeEventListener('scroll', listener, true);\n\t\t\t}\n\n\t\t\tattached.delete(id);\n\t\t}\n\t};\n}\n","import isEmpty from 'lodash/isEmpty';\nimport isString from 'lodash/isString';\nimport isNumber from 'lodash/isNumber';\nimport isArray from 'lodash/isArray';\nimport mapValues from 'lodash/mapValues';\nimport normalizePosition from './normalize-position';\n\nfunction positionToFitShorthand(position) {\n\tif (isString(position)) {\n\t\treturn position;\n\t}\n\n\tconst target = position.trigger || position.target;\n\tif (position.content) {\n\t\treturn `${target} ${position.content}`;\n\t}\n\n\treturn target;\n}\n\n/**\n * Popovers with tails default to centered positions.\n * Popovers without tails default to being aligned on some axis.\n */\nfunction resolvePosition(hideTail, positions, dir) {\n\t// Always prefer the positions provided by the consumer\n\tif (Array.isArray(positions) && !isEmpty(positions)) {\n\t\tpositions = positions.map(positionToFitShorthand);\n\t} else {\n\t\tpositions = hideTail\n\t\t\t? [\n\t\t\t\t\t'bottom-start top-start',\n\t\t\t\t\t'bottom-end top-end',\n\n\t\t\t\t\t'top-start bottom-start',\n\t\t\t\t\t'top-end bottom-end',\n\n\t\t\t\t\t'top-end top-start',\n\t\t\t\t\t'bottom-end bottom-start',\n\n\t\t\t\t\t'top-start top-end',\n\t\t\t\t\t'bottom-start bottom-end'\n\t\t\t  ]\n\t\t\t: [\n\t\t\t\t\t'top-center bottom-center',\n\t\t\t\t\t'bottom-center top-center',\n\t\t\t\t\t'center-end center-start',\n\t\t\t\t\t'center-start center-end'\n\t\t\t  ];\n\t}\n\n\treturn positions.map((position) => normalizePosition(position, dir));\n}\n\nfunction resolveOffset(hideTail, offset) {\n\tif (isNumber(offset) || isArray(offset)) {\n\t\treturn offset;\n\t}\n\treturn hideTail ? 0 : 12;\n}\n\nfunction resolveConstrain(constrain) {\n\treturn mapValues(constrain, (value) =>\n\t\tvalue === 'trigger' ? 'target' : value\n\t);\n}\n\n/**\n * Compute properties that are important for fit, based on both the properties\n * that are passed in to the component and sane defaults which are different\n * whether or not we're rendering a tail.\n */\nexport default function resolveFitProperties({\n\thideTail,\n\tpositions,\n\tconstrain,\n\toffset,\n\tdir\n}) {\n\treturn {\n\t\tpositions: resolvePosition(hideTail, positions, dir),\n\t\toffset: resolveOffset(hideTail, offset),\n\t\tconstrain: resolveConstrain(constrain)\n\t};\n}\n","module.exports = __TECTONIC__lodash_4_17_4[\"isString\"];","module.exports = __TECTONIC__lodash_4_17_4[\"isNumber\"];","module.exports = __TECTONIC__lodash_4_17_4[\"isArray\"];","module.exports = __TECTONIC__lodash_4_17_4[\"mapValues\"];","const normalizeOrigin = (origin, dir) =>\n\torigin\n\t\t.replace(/-(start|end|left|right)$/, (match, group) => {\n\t\t\tconst isStart = group === 'start' || group === 'left';\n\n\t\t\tif (dir === 'rtl') {\n\t\t\t\treturn isStart ? '-end' : '-start';\n\t\t\t}\n\n\t\t\treturn isStart ? '-start' : '-end';\n\t\t})\n\t\t.split('-');\n\nconst toMatchingOrigin = ([vertical, horizontal]) => {\n\t// If vertical is center, flip the horizontal position\n\tif (vertical === 'center') {\n\t\treturn horizontal === 'start' ? ['center', 'end'] : ['center', 'start'];\n\t}\n\t// Otherwise flip the vertical position\n\treturn vertical === 'top' ? ['bottom', horizontal] : ['top', horizontal];\n};\n\nconst RE_POSITION_LONG = /^(top|bottom|center)-(left|right|start|end|center) (top|bottom|center)-(left|right|start|end|center)$/;\nconst RE_POSITION_SHORT = /^(top|bottom|center)-(left|right|start|end|center)$/;\n\n/**\n * Normalizes a position based on the following rules:\n * - if a position shorthand is provided, expands it to the full position (e.g. \"bottom-start\" > \"bottom-start top-start\")\n * - normalizes direction-specific inline properties to logical properties (e.g. \"bottom-right top-left\" > \"bottom-end top-start\")\n * - splits the normalized position into two arrays of origins (e.g. \"bottom-end top-start\" > [[\"bottom\", \"end\"], [\"top\", \"start\"]])\n * @param {string} position - Shorthand position (\"bottom-start\") or full position (\"bottom-right top-left\")\n * @return {Array<Origin[]>}\n */\nexport default function normalizePosition(position, dir) {\n\tif (RE_POSITION_LONG.test(position)) {\n\t\tconst [targetOrigin, contentOrigin] = position.split(' ');\n\t\treturn [\n\t\t\tnormalizeOrigin(targetOrigin, dir),\n\t\t\tnormalizeOrigin(contentOrigin, dir)\n\t\t];\n\t}\n\tif (RE_POSITION_SHORT.test(position)) {\n\t\tconst targetOrigin = normalizeOrigin(position, dir);\n\t\tconst contentOrigin = toMatchingOrigin(targetOrigin);\n\t\treturn [targetOrigin, contentOrigin];\n\t}\n\tthrow new Error(`${position} is not a valid position`);\n}\n","module.exports = __TECTONIC__resize_observer_polyfill_1_5_1;","module.exports = __TECTONIC__$servicenow_behavior_focus_19_8_3;","import {createEnhancedElement} from '@servicenow/library-enhanced-element';\nimport styles from './_now-popover-panel.scss';\nimport {actionTypes} from '@servicenow/ui-core';\n\nconst {COMPONENT_DOM_READY} = actionTypes;\n\nconst view = (state) => {\n\tconst {tailDirection, disableScroll} = state.properties;\n\treturn (\n\t\t<div\n\t\t\tid=\"fit-content-area\"\n\t\t\tclass={{\n\t\t\t\t'fit-content-area': true,\n\t\t\t\t'has-tail': tailDirection,\n\t\t\t\t[`-${tailDirection}`]: tailDirection,\n\t\t\t\t'disable-scroll': disableScroll\n\t\t\t}}>\n\t\t\t<div id=\"fit-content\" className=\"fit-content\">\n\t\t\t\t<slot name=\"content\" />\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\n/**\n * Panel element that holds markup and styles required to correctly position\n * popover content relative to its trigger element.\n *\n * This component should not be used outside of the now-popover implementation.\n *\n * ```jsx\n * <now-popover-panel tail-direction=\"up\">\n *   <now-my-dialog slot=\"content\" />\n * </now-popover>\n * ```\n *\n * @seismicElement now-popover-panel\n * @private\n * @summary A container for popover content.\n */\ncreateEnhancedElement('now-popover-panel', {\n\tproperties: {\n\t\t/**\n\t\t * Direction to display the tail.\n\t\t * @type {\"up\"|\"down\"|\"left\"|\"right\"}\n\t\t * @private\n\t\t */\n\t\ttailDirection: {},\n\n\t\t/**\n\t\t * Function to call once the panel has\n\t\t * been rendered\n\t\t * @type {(HTMLElement) => void}\n\t\t * @private\n\t\t */\n\t\tonReady: {},\n\t\t/**\n\t\t * If true, content in the popover panel will not overflow with a scrollbar.\n\t\t * Use this flag if your popover content already contains a custom\n\t\t * scroll container for handling overflowed content.\n\t\t * @type {boolean}\n\t\t * @private\n\t\t */\n\t\tdisableScroll: {}\n\t},\n\tactionHandlers: {\n\t\t[COMPONENT_DOM_READY]({host, properties}) {\n\t\t\tproperties.onReady(host);\n\t\t}\n\t},\n\tslots: {\n\t\t/**\n\t\t * Contains popover content to float above other content on the\n\t\t * page.\n\t\t */\n\t\tcontent: {}\n\t},\n\tstyles,\n\tview\n});\n","\n        var result = require(\"!!../../../node_modules/css-loader/index.js!../../../node_modules/postcss-loader/src/index.js??ref--6-2!../../../node_modules/sass-loader/dist/cjs.js??ref--6-3!./_now-popover-panel.scss\");\n\n        if (typeof result === \"string\") {\n            module.exports = result;\n        } else {\n            module.exports = result.toString();\n        }\n    ","exports = module.exports = require(\"../../../node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.id, \":host{box-sizing:border-box;line-height:var(--now-line-height,1.25);font-family:var(--now-font-family,\\\"Source Sans Pro\\\",sans-serif)}:host([hidden]){display:none}*,:after,:before{box-sizing:border-box}:host{position:relative;display:block;width:0;height:0}.fit-content-area{z-index:4000;visibility:hidden}.fit-content-area.has-tail:after,.fit-content-area.has-tail:before{content:\\\" \\\";position:absolute;width:0;height:0;border:solid transparent;pointer-events:none}.fit-content-area.has-tail:before{border-width:.625rem;filter:drop-shadow(0 2px 2px rgba(0,0,0,.3))}.fit-content-area.has-tail:after{border-width:.5625rem}.fit-content-area.has-tail.-up:before{top:-.5625rem;left:var(--popover-tail,1px);border-top:0;border-bottom-color:RGB(var(--mv9-XvXvstZ--kvZptZ-JvjvZ,var(--mv9-TtmW--kvZptZ-JvjvZ,var(--now-color_border--secondary,var(--now-color--neutral-5,172,180,181)))))}.fit-content-area.has-tail.-up:after{top:-.5rem;left:calc(var(--popover-tail, 0px) + 1px);border-top:0;border-bottom-color:RGB(var(--mv9-XvXvstZ--krJUfZvWmp-JvjvZ,var(--mv9-TtmW--krJUfZvWmp-JvjvZ,var(--now-color_background--primary,var(--now-color--neutral-0,255,255,255)))))}.fit-content-area.has-tail.-down:before{bottom:-.5625rem;left:var(--popover-tail,1px);border-top-color:RGB(var(--mv9-XvXvstZ--kvZptZ-JvjvZ,var(--mv9-TtmW--kvZptZ-JvjvZ,var(--now-color_border--secondary,var(--now-color--neutral-5,172,180,181)))));border-bottom:0}.fit-content-area.has-tail.-down:after{bottom:-.5rem;left:calc(var(--popover-tail, 0px) + 1px);border-top-color:RGB(var(--mv9-XvXvstZ--krJUfZvWmp-JvjvZ,var(--mv9-TtmW--krJUfZvWmp-JvjvZ,var(--now-color_background--primary,var(--now-color--neutral-0,255,255,255)))));border-bottom:0}.fit-content-area.has-tail.-right:before{top:var(--popover-tail,1px);right:-.5625rem;border-right:0;border-left-color:RGB(var(--mv9-XvXvstZ--kvZptZ-JvjvZ,var(--mv9-TtmW--kvZptZ-JvjvZ,var(--now-color_border--secondary,var(--now-color--neutral-5,172,180,181)))))}.fit-content-area.has-tail.-right:after{top:calc(var(--popover-tail, 0px) + 1px);right:-.5rem;border-right:0;border-left-color:RGB(var(--mv9-XvXvstZ--krJUfZvWmp-JvjvZ,var(--mv9-TtmW--krJUfZvWmp-JvjvZ,var(--now-color_background--primary,var(--now-color--neutral-0,255,255,255)))))}.fit-content-area.has-tail.-left:before{top:var(--popover-tail,1px);left:-.5625rem;border-right-color:RGB(var(--mv9-XvXvstZ--kvZptZ-JvjvZ,var(--mv9-TtmW--kvZptZ-JvjvZ,var(--now-color_border--secondary,var(--now-color--neutral-5,172,180,181)))));border-left:0}.fit-content-area.has-tail.-left:after{top:calc(var(--popover-tail, 0px) + 1px);left:-.5rem;border-right-color:RGB(var(--mv9-XvXvstZ--krJUfZvWmp-JvjvZ,var(--mv9-TtmW--krJUfZvWmp-JvjvZ,var(--now-color_background--primary,var(--now-color--neutral-0,255,255,255)))));border-left:0}.fit-content{position:fixed;overflow:auto;max-width:100%;max-height:100%;border-width:1px;border-style:solid;border-color:RGB(var(--mv9-XvXvstZ--kvZptZ-JvjvZ,var(--mv9-TtmW--kvZptZ-JvjvZ,var(--now-color_border--secondary,var(--now-color--neutral-5,172,180,181)))));border-radius:var(--mv9-XvXvstZ--kvZptZ-ZrpAW1,var(--mv9-TtmW--kvZptZ-ZrpAW1,.125rem));box-shadow:0 2px .25rem 0 RGBA(var(--now-color--neutral-21,0,0,0),.25);background-color:RGB(var(--mv9-XvXvstZ--krJUfZvWmp-JvjvZ,var(--mv9-TtmW--krJUfZvWmp-JvjvZ,var(--now-color_background--primary,var(--now-color--neutral-0,255,255,255)))))}.disable-scroll .fit-content{overflow:hidden}\", \"\"]);\n\n// exports\n","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n"],"sourceRoot":""}